<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://simplecoder.cn/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://simplecoder.cn/">





  <title>Hexo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/iOS新特性及适配/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/iOS新特性及适配/" itemprop="url">iOS11新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS进阶/" itemprop="url" rel="index">
                    <span itemprop="name">iOS进阶</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iOS-11-0-新特性"><a href="#iOS-11-0-新特性" class="headerlink" title="iOS 11.0 新特性"></a>iOS 11.0 新特性</h2><h3 id="1-UIViewController"><a href="#1-UIViewController" class="headerlink" title="1.UIViewController"></a>1.UIViewController</h3><hr>
<h3 id="2-UIScrollView"><a href="#2-UIScrollView" class="headerlink" title="2.UIScrollView"></a>2.UIScrollView</h3><hr>
<h3 id="3-UINavigationBar"><a href="#3-UINavigationBar" class="headerlink" title="3.UINavigationBar"></a>3.UINavigationBar</h3><hr>
<h3 id="4-UITableView"><a href="#4-UITableView" class="headerlink" title="4.UITableView"></a>4.UITableView</h3><p><a href="https://www.jianshu.com/p/d4a17c32abdf" target="_blank" rel="noopener">参考连接 1</a></p>
<p><a href="https://www.jianshu.com/p/db8d5c22c10e?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">参考连接 2</a></p>
<h2 id="iOS-11-0-适配"><a href="#iOS-11-0-适配" class="headerlink" title="iOS 11.0 适配"></a>iOS 11.0 适配</h2><p><a href="https://www.jianshu.com/p/de19e9cda481" target="_blank" rel="noopener">参考连接 1</a></p>
<p><a href="https://www.jianshu.com/p/efbc8619d56b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">参考连接 2</a></p>
<p><a href="https://github.com/coderketao/iOS11-iPhoneX" target="_blank" rel="noopener">iPhone X 适配</a></p>
<h2 id="iOS-10-0-新特性和适配"><a href="#iOS-10-0-新特性和适配" class="headerlink" title="iOS 10.0 新特性和适配"></a>iOS 10.0 新特性和适配</h2><p><a href="https://github.com/ChenYilong/iOS10AdaptationTips" target="_blank" rel="noopener">参考连接 1</a></p>
<h2 id="iOS-9-0-新特性和适配"><a href="#iOS-9-0-新特性和适配" class="headerlink" title="iOS 9.0 新特性和适配"></a>iOS 9.0 新特性和适配</h2><p><a href="https://github.com/ChenYilong/iOS9AdaptationTips#1-demo1_ios9网络适配_ats改用更安全的https" target="_blank" rel="noopener">iOS9.0适配参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/KVC&KVO/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/KVC&KVO/" itemprop="url">KVO和KVC底层原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="KVO和KVC底层原理"><a href="#KVO和KVC底层原理" class="headerlink" title="KVO和KVC底层原理"></a>KVO和KVC底层原理</h1><p>我们知道，ObjC有很多类似于Python的动态特性。例如动态类型、动态加载、动态绑定等。依赖于这种动态特性，我们得以实现Objc中许多我们熟知的实用功能，比如键值监听（KVO）与键值编码（KVC）。</p>
<h2 id="键值监听KVO"><a href="#键值监听KVO" class="headerlink" title="键值监听KVO"></a>键值监听KVO</h2><h3 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h3><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。</p>
<p>在ObjC中使用KVO操作常用的方法如下：</p>
<ul>
<li>注册指定Key路径的监听器： <strong>addObserver: forKeyPath: options:  context:</strong></li>
<li>删除指定Key路径的监听器： <strong>removeObserver: forKeyPath</strong>、<strong>removeObserver: forKeyPath: context:</strong></li>
<li>回调监听： <strong>observeValueForKeyPath: ofObject: change: context:</strong></li>
</ul>
<p>KVO的使用步骤也比较简单：</p>
<ol>
<li>通过addObserver: forKeyPath: options: context:为被监听对象（它通常是数据模型）注册监听器</li>
<li>重写监听器的observeValueForKeyPath: ofObject: change: context:方法</li>
</ol>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p1.age = <span class="number">1</span>;</span><br><span class="line">    p1.age = <span class="number">2</span>;</span><br><span class="line">    p2.age = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// self 监听 p1的 age属性</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line"></span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    [p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@改变了%@"</span>, object, keyPath,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line">监听到&lt;Person: <span class="number">0x604000205460</span>&gt;的age改变了&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">10</span>;</span><br><span class="line">    old = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部实现分析"><a href="#内部实现分析" class="headerlink" title="内部实现分析"></a>内部实现分析</h3><p>上述代码中可以看出，在添加监听之后，age属性的值在发生改变时，就会通知到监听者，执行监听者的<code>observeValueForKeyPath</code>方法。</p>
<p>那么，被监听者内部做了什么操作来实现这样神奇的功能？</p>
<p>首先我们想到的可能就是重写了Observer内部属性的set方法。我们可以来到上述Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。通过上一节的OC对象本质的学习我们知道，对象在调用实例方法的时候，会通过isa指针找到其类对象，在类对象内部调用方法的实现。</p>
<p>按照上面的分析，p1和p2对象应该都是统一调用了存放在Person类对象内部的set方法才合理。</p>
<p>但是我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，结果是p1除了调用set方法之外还会另外执行监听器的<code>observeValueForKeyPath</code>方法。</p>
<h3 id="KVO的本质"><a href="#KVO的本质" class="headerlink" title="KVO的本质"></a>KVO的本质</h3><p>还是上面的例子。KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setAge:方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。</p>
<p>首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针如下图所示</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw4ke1208gj30it0680u3.jpg" alt="addObserver对p1对象的处理"></p>
<p>通过上图我们发现，p1对象执行过addObserver操作之后，p1对象的isa指针由之前的指向类对象Person变为指向<code>NSKVONotifyin_Person</code>类对象，而p2对象没有任何改变。也就是说一旦p1对象添加了KVO监听以后，其isa指针就会发生变化，因此set方法的执行效果就不一样了。</p>
<p>那么我们先来观察p2对象在内容中是如何存储的，然后对比p2来观察p1。<br>首先我们知道，p2在调用setage方法的时候，首先会通过p2对象中的isa指针找到Person类对象，然后在类对象中找到setage方法。然后找到方法对应的实现。如下图所示</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw4kgl0aupj30pq0ca74x.jpg" alt="未使用KVO"></p>
<p>但是刚才我们发现p1对象的isa指针在经过KVO监听之后已经指向了<code>NSKVONotifyin_Person</code>类对象，<code>NSKVONotifyin_Person</code>其实是Person的子类，那么也就是说其superclass指针是指向Person类对象的，<code>NSKVONotifyin_Person</code>是runtime在运行时生成的。那么p1对象在调用setage方法的时候，肯定会根据p1的isa找到<code>NSKVONotifyin_Person</code>，在<code>NSKVONotifyin_Person</code>中找setAge:的方法及实现。</p>
<p><code>NSKVONotifyin_Person</code>中的setAge:方法中其实调用了 Fundation框架中C语言函数 <code>_NSsetIntValueAndNotify</code>，<code>_NSsetIntValueAndNotify</code>内部首先调用<code>willChangeValueForKey</code>将要改变方法，之后调用父类的setAge方法对成员变量赋值，最后调用<code>didChangeValueForKey</code>已经改变方法。<code>didChangeValueForKey</code>中会调用监听器的监听方法，最终来到监听者的observeValueForKeyPath方法中。</p>
<h3 id="另一种验证思路"><a href="#另一种验证思路" class="headerlink" title="另一种验证思路"></a>另一种验证思路</h3><p>其实，我们可以通过打印p1和p2所调用的setAge：方法地址来侧面验证我们的上述结论。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过methodForSelector找到方法实现的地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加KVO监听之前 - p1 = %p, p2 = %p"</span>, [p1 methodForSelector: <span class="keyword">@selector</span>(setAge:)],[p2 methodForSelector: <span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加KVO监听之后 - p1 = %p, p2 = %p"</span>, [p1 methodForSelector: <span class="keyword">@selector</span>(setAge:)],[p2 methodForSelector: <span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw4ksrfjkkj30qn04iacf.jpg" alt="监听前后地址"></p>
<p>我们发现在添加KVO监听之前，p1和p2的setAge方法实现的地址相同，而经过KVO监听之后，p1的setAge方法实现的地址发生了变化，我们通过打印方法实现来看一下前后的变化发现，确实如我们上面所讲的一样，p1的setAge方法的实现由Person类方法中的setAge方法转换为了C语言的Foundation框架的<code>_NSsetIntValueAndNotify</code>函数。</p>
<p>Foundation框架中会根据属性的类型，调用不同的方法。例如我们之前定义的int类型的age属性，那么我们看到Foundation框架中调用的<code>_NSsetIntValueAndNotify</code>函数。那么我们把age的属性类型变为<code>double</code>重新打印一遍</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw4kvsc74pj30oo04s0ur.jpg" alt="_NSSetDoubleValueAndNotify函数"></p>
<p>我们发现调用的函数变为了<code>_NSSetDoubleValueAndNotify</code>，那么这说明Foundation框架中有许多此类型的函数，通过属性的不同类型调用不同的函数。</p>
<p>那么我们可以推测Foundation框架中还有很多例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify</span><br></pre></td></tr></table></figure>
<p>等等函数。</p>
<p>我们可以找到Foundation框架文件，通过命令行查询关键字找到相关函数</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw4kxa5uisj30dw08nte8.jpg" alt="相关函数"></p>
<h3 id="动态生成类NSKVONotifyin-Person的内部组成"><a href="#动态生成类NSKVONotifyin-Person的内部组成" class="headerlink" title="动态生成类NSKVONotifyin_Person的内部组成"></a>动态生成类NSKVONotifyin_Person的内部组成</h3><p>首先我们知道，<code>NSKVONotifyin_Person</code>作为Person的子类，其superclass指针指向Person类，并且<code>NSKVONotifyin_Person</code>内部一定对setAge方法做了单独的实现，那么<code>NSKVONotifyin_Person</code>同Person类的差别可能就在于其内存储的对象方法及实现不同。<br> 我们通过runtime分别打印Person类对象和<code>NSKVONotifyin_Person</code>类对象内存储的对象方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    p1.age = <span class="number">1.0</span>;</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p1.age = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// self 监听 p1的 age属性</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p2)];</span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p1)];</span><br><span class="line"></span><br><span class="line">    [p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) printMethods:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count ;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [methodNames appendFormat:<span class="string">@"%@ - "</span>, cls];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        <span class="built_in">NSString</span> *methodName  = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line">        </span><br><span class="line">        [methodNames appendString: methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@" "</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw4l1irymsj30i901gq3e.jpg" alt="NSKVONotifyin_Person内存储的对象方法"></p>
<p>通过上述代码我们发现<code>NSKVONotifyin_Person</code>中有4个对象方法。分别为<code>setAge: class dealloc _isKVOA</code>，那么至此我们可以画出<code>NSKVONotifyin_Person</code>的内存结构以及方法调用顺序。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw4l4no1f3j30sg0ghwg9.jpg" alt="NSKVONotifyin_Person的内存结构以及方法调用顺序"></p>
<p>这里<code>NSKVONotifyin_Person</code>重写class方法是为了隐藏<code>NSKVONotifyin_Person</code>。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@,%@"</span>,[p1 <span class="keyword">class</span>],[p2 <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">// 打印结果 Person,Person</span></span><br></pre></td></tr></table></figure>
<p>如果<code>NSKVONotifyin_Person</code>不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到NSObject，而NSObject的Class的实现大致为返回自己isa指向的类，返回p1的isa指向的类。那么打印出来的类就是<code>NSKVONotifyin_Person</code>，但是apple不希望将<code>NSKVONotifyin_Person</code>类暴露出来，并且不希望我们知道<code>NSKVONotifyin_Person</code>内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。</p>
<p>那么我们可以猜测<code>NSKVONotifyin_Person</code>内重写的class内部实现大致为</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (Class) <span class="keyword">class</span> &#123;</span><br><span class="line">     <span class="comment">// 得到类对象，在找到类对象父类</span></span><br><span class="line">     <span class="keyword">return</span> class_getSuperclass(object_getClass(<span class="keyword">self</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##键值编码KVC</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>KVC的操作方法由<code>NSKeyValueCoding</code>协议提供，而NSObject就实现了这个协议，也就是说ObjC中几乎所有的对象都支持KVC操作，常用的KVC操作方法如下：</p>
<ul>
<li>动态设置： <strong>setValue:属性值 forKey:属性名</strong>（用于简单路径）、<strong>setValue:属性值 forKeyPath:属性路径</strong>（用于复合路径，例如Person有一个Account类型的属性，那么person.account就是一个复合属性）</li>
<li>动态读取： <strong>valueForKey:属性名</strong> 、<strong>valueForKeyPath:属性名</strong>（用于复合路径）</li>
</ul>
<h4 id="底层调用顺序"><a href="#底层调用顺序" class="headerlink" title="底层调用顺序"></a>底层调用顺序</h4><h5 id="setValue-forKey"><a href="#setValue-forKey" class="headerlink" title="setValue:forKey:"></a>setValue:forKey:</h5><ul>
<li>首先调用setKey:方法对对应的key进行设置，如果没有找到setKey方法，则查找以下划线开头的方法_setKey</li>
<li>如果第一步的两个方法实现都没找到，则会调用类方法<code>accessInstanceVariablesDirectly</code>询问能否直接访问成员变量，系统默认返回<code>YES</code>。</li>
<li>如果第二步的方法中返回值为<code>YES</code>，则成员变量会按照以下顺序进行查找，<code>_key、_isKey、key、isKey</code>如果找到了直接进行赋值。</li>
<li>如果第二步返回为<code>NO</code>,调用<code>setValue:forUndefinedKey:</code>并抛出异常<code>NSUnknownKeyException</code></li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw4nh8y3dyj31kw0ls0z1.jpg" alt="setValue:forKey:方法调用顺序"></p>
<h5 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey:"></a>valueForKey:</h5><ul>
<li>第一步是按照<code>getKey、key、 isKey、_key</code>的方法调用顺序去查找，如果找到直接调用对应的方法</li>
<li>接下来调用<code>accessInstanceVariablesDirectly</code>询问是否能直接访问成员变量，系统默认返回的是<code>YES</code></li>
<li>如果自己实现了第二步的方法，并且返回<code>NO</code>，则会调用<code>valueForUndefinedKey:</code>并抛出异常<code>NSUnknownKeyException</code>。否则执行第四步</li>
<li>按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量,如果找到了，直接取值。否则会调用<code>valueForUndefinedKey:</code>并抛出异常<code>NSUnknownKeyException</code>。</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw4q7smnjdj318f0fy775.jpg" alt="valueForKey:方法调用顺序"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>KVO的本质是利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类。当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数。此函数内部会调用如下的方法</p>
<ul>
<li>willChangeValueForKey:</li>
<li>父类原来的setter</li>
<li>didChangeValueForKey：</li>
</ul>
<p>最后一步内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）。</p>
<p>所以这路我们可以得出一个结论，如果想要手动出发KVO，我们可以手动去调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>两个方法即可。因为KVO底层是通过调用set方法实现，所以如果直接修改成员变量的话，并不会触发KVO机制。</p>
<p>最后，我们观察到，如果通过KVC的方式进行赋值的话，会触发KVO。根据上一节对KVC机制的分析我们得知，存在某些时刻KVC会直接访问成员变量而不是调用成员变量的set方法。但是这种情况下KVO依然有效的原因我们不难想象，肯定是在KVC直接访问成员变量的过程中，调用了<code>willChangeValueForKey:</code>和<code>didChangeValueForKey：</code>所致。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/CoreText/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/CoreText/" itemprop="url">CoreText 框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CoreText-框架"><a href="#CoreText-框架" class="headerlink" title="CoreText 框架"></a>CoreText 框架</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章参考自唐巧<strong>《iOS开发进阶》</strong>，对其中的细节难点进行了补充说明。</p>
<p>使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。</p>
<h2 id="CoreText-简介"><a href="#CoreText-简介" class="headerlink" title="CoreText 简介"></a>CoreText 简介</h2><p>CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。</p>
<p>Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。</p>
<p>下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。</p>
<blockquote>
<p>注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。</p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr78975z22j30l507o3zm.jpg" alt="coretext_arch"></p>
<p>UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处：</p>
<ul>
<li>CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。</li>
<li>CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取）</li>
<li>CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。</li>
<li>基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。</li>
</ul>
<p>当然，基于 CoreText 的排版方案也有一些劣势：</p>
<ul>
<li>CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。</li>
<li>基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。</li>
</ul>
<h2 id="CoreText基本用法"><a href="#CoreText基本用法" class="headerlink" title="CoreText基本用法"></a>CoreText基本用法</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="字体（Font）"><a href="#字体（Font）" class="headerlink" title="字体（Font）"></a>字体（Font）</h4><p>和我们平时说的字体不同，计算机意义上的字体表示的是同一大小，同一样式(Style)字形的集合。从这个意义上来说，当我们为文字设置粗体，斜体时其实是使用了另外一种字体(下划线不算)。而平时我们所说的字体只是具有相同设计属性的字体集合，即Font Family或typeface。 </p>
<h4 id="字符-Character-和字形-Glyphs"><a href="#字符-Character-和字形-Glyphs" class="headerlink" title="字符(Character)和字形(Glyphs)"></a>字符(Character)和字形(Glyphs)</h4><p>排版过程中一个重要的步骤就是从字符到字形的转换，字符表示信息本身，而字形是它的图形表现形式。字符一般就是指某种编码，如Unicode编码，而字形则是这些编码对应的图片。但是他们之间不是一一对应关系，同个字符的不同字体族，不同字体大小，不同字体样式都对应了不同的字形。而由于连写(Ligatures)的存在，多个字符也会存在对应一个字形的情况。 </p>
<p>下面就来详细看看字形的各个参数也就是所谓的字形度量Glyph Metrics  <img src="https://ws1.sinaimg.cn/large/006tNc79ly1fr78950igoj30uu0t2aca.jpg" alt="20160830140956257"></p>
<ul>
<li><p>边界框 bbox(bounding box) </p>
<p>这是一个假想的框子，它尽可能紧密的装入字形。</p>
</li>
<li><p>基线(baseline) </p>
<p>一条假想的线,一行上的字形都以此线作为上下位置的参考，在这条线的左侧存在一个点叫做基线的原点， </p>
</li>
<li><p>上行高度(ascent) </p>
<p>从原点到字体中最高（这里的高深都是以基线为参照线的）的字形的顶部的距离，ascent是一个正值</p>
</li>
<li><p>下行高度(descent) </p>
<p>从原点到字体中最深的字形底部的距离，descent是一个负值（比如一个字体原点到最深的字形的底部的距离为2，那么descent就为-2）</p>
</li>
<li><p>行距(line gap) </p>
<p>line gap也可以称作leading（其实准确点讲应该叫做External leading）,行高line Height则可以通过 ascent + |descent| + linegap 来计算。 </p>
</li>
<li><p>字间距(Kerning) </p>
<p>字与字之间的距离，为了排版的美观，并不是所有的字形之间的距离都是一致的，但是这个基本步影响到我们的文字排版。 </p>
</li>
<li><p>基础原点(Origin) </p>
<p>基线上最左侧的点。<img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr78968zy9j30oo07kdgl.jpg" alt="20160830145626529"></p>
<p>红框高度既为当前行的行高，绿线为baseline，绿色到红框上部分为当前行的最大Ascent，绿线到黄线为当前行的最大Desent，而黄框的高即为行间距。由此可以得出：lineHeight = Ascent + |Decent| + Leading。</p>
</li>
</ul>
<h4 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h4><p>传统的Mac中的坐标系的原点在左下角，比如NSView默认的坐标系，原点就在左下角。但Mac中有些View为了其实现的便捷将原点变换到左上角，像NSTableView的坐标系坐标原点就在左上角。</p>
<p>iOS UIKit中，UIView是以左上角为原点，而Core Text一开始的定位是使用与桌面应用的排版系统，桌面应用的坐标系是以左下角为原点，即Core Text在绘制的时候也是参照左下角为原点进行绘制的，所以需要对当前的坐标系进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//因为Core Text要配合Core Graphic 配合使用的，如Core Graphic一样，绘图的时候需要获得当前的上下文进行绘制</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">//翻转当前的坐标系（因为对于底层绘制引擎来说，屏幕左下角为（0，0））</span><br><span class="line">//设置文本不进行变换</span><br><span class="line">CGContextSetTextMatrix(context, CGAffineTransformIdentity);</span><br><span class="line">//向下平移整个画布单位</span><br><span class="line">CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">//对平移后的画布进行翻转</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br></pre></td></tr></table></figure>
<h3 id="CoreText对象模型"><a href="#CoreText对象模型" class="headerlink" title="CoreText对象模型"></a>CoreText对象模型</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr7896p54yj30dw09ggmc.jpg" alt="CTClasses-500x340"></p>
<ol>
<li><p>CTFramesetterRef</p>
<p>通过CFAttributedStringRef进行初始化，它作为CTFrame对象的生产工厂，负责根据path生产对应的CTFrame；</p>
</li>
<li><p>CTFrame</p>
<p>CTFrame是可以通过CTFrameDraw函数直接绘制到context上的，当然你可以在绘制之前，操作CTFrame中的CTLine，进行一些参数的微调；</p>
</li>
<li><p>CTLine</p>
<p>在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行；可以看做Core Text绘制中的一行的对象，通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs；</p>
</li>
<li><p>CTRun</p>
<p>或者叫做 Glyph Run，每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本，是一组共享想相同attributes（属性）的字形的集合体；</p>
</li>
</ol>
<p>总结：</p>
<p>CTFramesetter是由CFAttributedString(NSAttributedString)初始化而来，可以认为它是CTFrame的一个Factory，通过传入CGPath生成相应的CTFrame并使用它进行渲染：直接以CTFrame为参数使用CTFrameDraw绘制或者从CTFrame中获取CTLine进行微调后使用CTLineDraw进行绘制。CTFrame 作为一个整体的画布(Canvas)，其中由行(CTLine)组成，而每行可以分为一个或多个小方块（CTRun）。</p>
<blockquote>
<p>注意：你不需要自己创建CTRun，Core Text将根据NSAttributedString的属性来自动创建CTRun。每个CTRun对象对应不同的属性，正因此，你可以自由的控制字体、颜色、字间距等等信息。</p>
</blockquote>
<h3 id="通常的处理步骤"><a href="#通常的处理步骤" class="headerlink" title="通常的处理步骤"></a>通常的处理步骤</h3><ol>
<li>获取上下文</li>
<li>翻转坐标系</li>
<li>创建NSAttributedString</li>
<li>根据NSAttributedString创建CTFramesetterRef</li>
<li>创建绘制区域CGPathRef（该CGPathRef是库CoreGraphics里边的，初始原点为左上角；翻转后，原点为左下角）</li>
<li>根据CTFramesetterRef和CGPathRef创建CTFrame</li>
<li>CTFrameDraw绘制。</li>
</ol>
<h2 id="CoreText示例程序"><a href="#CoreText示例程序" class="headerlink" title="CoreText示例程序"></a>CoreText示例程序</h2><p>首先从一个简单的绘制文字示例开始：</p>
<p>自定义一个<code>CTDisplayView</code>，让其 import 头文件<code>CoreText/CoreText.h</code>，接着输入以下代码来实现其<code>drawRect</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CTDisplayView.h&quot;</span><br><span class="line">#import &quot;CoreText/CoreText.h&quot;</span><br><span class="line">@implementation CTDisplayView</span><br><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    // 步骤 1</span><br><span class="line">    //因为Core Text要配合Core Graphic 配合使用的，如Core Graphic一样，绘图的时候需要获得当前的上下文		进行绘制</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    // 步骤 2</span><br><span class="line">    //翻转当前的坐标系（因为对于底层绘制引擎来说，屏幕左下角为（0，0））</span><br><span class="line">	//设置文本不进行变换</span><br><span class="line">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);</span><br><span class="line">    //向下平移整个画布单位</span><br><span class="line">    CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">    //对平移后的画布进行翻转</span><br><span class="line">    CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">    // 步骤 3</span><br><span class="line">    //创建画布边框路径</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, self.bounds);</span><br><span class="line">    // 步骤 4</span><br><span class="line">    NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@&quot;Hello World!&quot;];</span><br><span class="line">    //通过NSAttributedString创建framesetter</span><br><span class="line">    CTFramesetterRef framesetter =</span><br><span class="line">    CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attString);</span><br><span class="line">    //创建CTFrame对象，这里第二个参数为一个Range范围用来确定framesetter。一般传入字符串的长度，如果设为0的话那么framesetter将继续添加行直到它用完文本或空间。第四个参数为其他属性，一般不需要，设为NULL即可。</span><br><span class="line">    CTFrameRef frame =</span><br><span class="line">    CTFramesetterCreateFrame(framesetter,</span><br><span class="line">                             CFRangeMake(0, [attString length]), path, NULL);</span><br><span class="line">    // 步骤 5 绘制</span><br><span class="line">    CTFrameDraw(frame, context);</span><br><span class="line">    // 步骤 6 </span><br><span class="line">    //CoreFoundation需要自己手动管理内存</span><br><span class="line">    CFRelease(frame);</span><br><span class="line">    CFRelease(path);</span><br><span class="line">    CFRelease(framesetter);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行结果：<img src="https://ws1.sinaimg.cn/large/006tNc79ly1fr7897n4iwj30dq0l00t1.jpg" alt="coretext-5"></p>
<h3 id="排版引擎框架"><a href="#排版引擎框架" class="headerlink" title="排版引擎框架"></a>排版引擎框架</h3><p>上面的 示例仅仅展示了 Core Text 排版的基本能力。但是要制作一个较完善的排版引擎，我们不能简单的将所有代码都放到 <code>CTDisplayView</code> 的<code>drawRect</code>方法里面。根据设计模式中的 “ 单一功能原则 “(<code>Single responsibility principle</code>)，我们应该把功能拆分，把不同的功能都放到各自不同的类里面。</p>
<p>对于一个复杂的排版引擎来说，可以将其功能拆成以下几个类来完成：</p>
<ol>
<li>一个显示用的类，仅负责显示内容，不负责排版</li>
<li>一个模型类，用于承载显示所需要的所有数据</li>
<li>一个排版类，用于实现文字内容的排版</li>
<li>一个配置类，用于实现一些排版时的可配置项</li>
</ol>
<p>注：” 单一功能原则 “参考链接 <a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">Single responsibility principle</a></p>
<p>按照以上原则，我们将<code>CTDisplayView</code>中的部分内容拆开，由 4 个类构成：</p>
<ol>
<li><code>CTFrameParserConfig</code>类，用于配置绘制的参数，例如：文字颜色，大小，行间距等。</li>
<li><code>CTFrameParser</code>类，用于生成最后绘制界面需要的<code>CTFrameRef</code>实例。</li>
<li><code>CoreTextData</code>类，用于保存由<code>CTFrameParser</code>类生成的<code>CTFrameRef</code>实例以及<code>CTFrameRef</code>实际绘制需要的高度。</li>
<li><code>CTDisplayView</code>类，持有<code>CoreTextData</code>类的实例，负责将<code>CTFrameRef</code>绘制到界面上。</li>
</ol>
<p>关于这 4 个类的关键代码如下：</p>
<p><code>CTFrameParserConfig</code>类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface CTFrameParserConfig : NSObject</span><br><span class="line">/**</span><br><span class="line"> 颜色</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) UIColor *textColor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 宽度</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) CGFloat width;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 字号</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) CGFloat fontSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 行高</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) CGFloat lineSpace;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CTFrameParserConfig.h&quot;</span><br><span class="line">#import &quot;UIColor+Extend.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation CTFrameParserConfig</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _width = 200.0f;</span><br><span class="line">        _fontSize = 16.0f;</span><br><span class="line">        _lineSpace = 8.0f;</span><br><span class="line">        _textColor = [UIColor colorFromHexRGB:@&quot;333333&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>CTFrameParser</code>类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;CoreTextData.h&quot;</span><br><span class="line">#import &quot;CTFrameParserConfig.h&quot;</span><br><span class="line">@interface CTFrameParser : NSObject</span><br><span class="line">+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CTFrameParser.h&quot;</span><br><span class="line">#import &quot;CTFrameParserConfig.h&quot;</span><br><span class="line">@implementation CTFrameParser</span><br><span class="line">+ (NSDictionary *)attributesWithConfig:(CTFrameParserConfig *)config &#123;</span><br><span class="line">    //创建字体 包括字形和大小</span><br><span class="line">    CGFloat fontSize = config.fontSize;</span><br><span class="line">    CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL);</span><br><span class="line">    //行高</span><br><span class="line">    CGFloat lineSpacing = config.lineSpace;</span><br><span class="line">    //段落属性</span><br><span class="line">    const CFIndex kNumberOfSettings = 3;</span><br><span class="line">    //创建段落属性的结构体数组 具体的段落属性值参考苹果官方文档</span><br><span class="line">    CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123;</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //创建段落属性</span><br><span class="line">    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings);</span><br><span class="line">    UIColor * textColor = config.textColor;</span><br><span class="line">    NSMutableDictionary * dict = [NSMutableDictionary dictionary];</span><br><span class="line">    dict[(id)kCTForegroundColorAttributeName] = (id)textColor.CGColor;</span><br><span class="line">    dict[(id)kCTFontAttributeName] = (__bridge id)fontRef;</span><br><span class="line">    dict[(id)kCTParagraphStyleAttributeName] = (__bridge id)theParagraphRef;</span><br><span class="line">    CFRelease(theParagraphRef);</span><br><span class="line">    CFRelease(fontRef);</span><br><span class="line">    return dict;</span><br><span class="line">&#125;</span><br><span class="line">+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    NSDictionary *attributes = [self attributesWithConfig:config];</span><br><span class="line">    NSAttributedString *contentString =</span><br><span class="line">        [[NSAttributedString alloc] initWithString:content</span><br><span class="line">                                        attributes:attributes];</span><br><span class="line">    // 创建 CTFramesetterRef 实例</span><br><span class="line">    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)contentString);</span><br><span class="line">    // 获得要绘制的区域的高度</span><br><span class="line">    CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX);</span><br><span class="line">    CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil);</span><br><span class="line">    CGFloat textHeight = coreTextSize.height;</span><br><span class="line">    // 生成 CTFrameRef 实例</span><br><span class="line">    CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight];</span><br><span class="line">    // 将生成好的 CTFrameRef 实例和计算好的绘制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例</span><br><span class="line">    CoreTextData *data = [[CoreTextData alloc] init];</span><br><span class="line">    data.ctFrame = frame;</span><br><span class="line">    data.height = textHeight;</span><br><span class="line">    // 释放内存</span><br><span class="line">    CFRelease(frame);</span><br><span class="line">    CFRelease(framesetter);</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter</span><br><span class="line">                                  config:(CTFrameParserConfig *)config</span><br><span class="line">                                  height:(CGFloat)height &#123;</span><br><span class="line">    //画布的路径（轮廓或者范围）</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height));</span><br><span class="line">    //最终生成绘制需要的frame，第二个参数表示文本范围，CFRangeMake(0,0)代表整个文本，最后一个参数为开发	   者自定义额外的属性，不需要填NULL即可。</span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL);</span><br><span class="line">    CFRelease(path);</span><br><span class="line">    return frame;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>CoreTextData</code>类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface CoreTextData : NSObject</span><br><span class="line">@property (assign, nonatomic) CTFrameRef ctFrame;</span><br><span class="line">@property (assign, nonatomic) CGFloat height;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CoreTextData.h&quot;</span><br><span class="line">@implementation CoreTextData</span><br><span class="line">// CTFrameRef 属于CoreText框架，需要自己手动管理内存。ARC机制在此不在适用，所以需要重写Settter</span><br><span class="line">- (void)setCtFrame:(CTFrameRef)ctFrame &#123;</span><br><span class="line">    if (_ctFrame != ctFrame) &#123;</span><br><span class="line">        if (_ctFrame != nil) &#123;</span><br><span class="line">            CFRelease(_ctFrame);</span><br><span class="line">        &#125;</span><br><span class="line">        CFRetain(ctFrame);</span><br><span class="line">        _ctFrame = ctFrame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    if (_ctFrame != nil) &#123;</span><br><span class="line">        CFRelease(_ctFrame);</span><br><span class="line">        _ctFrame = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>CTDisplayView</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;CoreTextData.h&quot;</span><br><span class="line">@interface CTDisplayView : UIView</span><br><span class="line">@property (strong, nonatomic) CoreTextData * data;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CTDisplayView.h&quot;</span><br><span class="line">@implementation CTDisplayView</span><br><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">   //因为Core Text要配合Core Graphic 配合使用的，如Core Graphic一样，绘图的时候需要获得当前的上下文进行绘制</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    //翻转当前的坐标系（因为对于底层绘制引擎来说，屏幕左下角为（0，0））</span><br><span class="line">    //设置文本不进行变换</span><br><span class="line">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);</span><br><span class="line">    //向下平移整个画布单位</span><br><span class="line">    CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">    //对平移后的画布进行翻转</span><br><span class="line">    CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">    if (self.data) &#123;</span><br><span class="line">        //绘制</span><br><span class="line">        CTFrameDraw(self.data.ctFrame, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>以下是本框架的 UML 示意图，从图中我们可以看出，这 4 个 Core Text 类的关系是这样的：</p>
<ol>
<li><code>CTFrameParser</code>通过<code>CTFrameparserConfig</code>实例来生成<code>CoreTextData</code>实例。</li>
<li><code>CTDisplayView</code>通过持有<code>CoreTextData</code>实例来获得绘制所需要的所有信息。</li>
<li><code>ViewController</code>类通过配置<code>CTFrameparserConfig</code>实例，进而获得生成的<code>CoreTextData</code>实例，最后将其赋值给他的<code>CTDisplayView</code>成员，达到将指定内容显示在界面上的效果。</li>
</ol>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr78984dimj30ky0ei0tp.jpg" alt="coretext-uml"></p>
<h3 id="定制排版文件格式"><a href="#定制排版文件格式" class="headerlink" title="定制排版文件格式"></a>定制排版文件格式</h3><p>对于上面的例子，我们给 CTFrameParser 使增加了一个将 NSString 转换为 CoreTextData 的方法。但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。例如，如果我们只想让内容的前三个字显示成红色，而其它文字显示成黑色，那么就办不到了。下面的示例程序中，我们通过解析一个json格式的文件来说明实现部分字体自定义、图文混排，点击事件的方法。</p>
<p>下面是我们需要的json模板，开发者可根据自己的排版需求定制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; </span><br><span class="line">    &quot;type&quot; : &quot;img&quot;,</span><br><span class="line">    &quot;width&quot; : 300,</span><br><span class="line">    &quot;height&quot; : 160,</span><br><span class="line">    &quot;name&quot; : &quot;coretext-image-1.jpg&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; &quot;color&quot; : &quot;blue&quot;,</span><br><span class="line">    &quot;content&quot; : &quot;对于上面的例子，我们给 CTFrameParser 使增加了一个将 NSString 转换为 CoreTextData 的方法 &quot;,</span><br><span class="line">    &quot;size&quot; : 16,</span><br><span class="line">    &quot;type&quot; : &quot;txt&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; &quot;color&quot; : &quot;red&quot;,</span><br><span class="line">    &quot;content&quot; : &quot;内容、颜色、字体&quot;,</span><br><span class="line">    &quot;size&quot; : 22,</span><br><span class="line">    &quot;type&quot; : &quot;txt&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; &quot;color&quot; : &quot;black&quot;,</span><br><span class="line">    &quot;content&quot; : &quot;大小等信息。\n&quot;,</span><br><span class="line">    &quot;size&quot; : 16,</span><br><span class="line">    &quot;type&quot; : &quot;txt&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; &quot;color&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;content&quot; : &quot;下面的示例程序中，我们通过解析一个json格式的文件来说明实现部分字体自定义、图文混排，点击事件的方法。&quot;,</span><br><span class="line">    &quot;type&quot; : &quot;txt&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; </span><br><span class="line">    &quot;type&quot; : &quot;img&quot;,</span><br><span class="line">    &quot;width&quot; : 50,</span><br><span class="line">    &quot;height&quot; : 32,</span><br><span class="line">    &quot;name&quot; : &quot;coretext-image-2.jpg&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; &quot;color&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;content&quot; : &quot;这在这里尝试放一个参考链接：&quot;,</span><br><span class="line">    &quot;type&quot; : &quot;txt&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; &quot;color&quot; : &quot;blue&quot;,</span><br><span class="line">    &quot;content&quot; : &quot;链接文字&quot;,</span><br><span class="line">    &quot;url&quot; : &quot;https://www.baidu.com&quot;,</span><br><span class="line">    &quot;type&quot; : &quot;link&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; &quot;color&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;content&quot; : &quot;大家可以尝试点击一下&quot;,</span><br><span class="line">    &quot;type&quot; : &quot;txt&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里首先解释一下，为什么需要这个json格式的文件。通常情况下，我们进行图文混排的时候，都需要找出string中需要特别处理的substring。比如我们Demo中的“内容、颜色、字体”，作为文本内容的一部分，需要显示为红色而不同于文本整体的颜色。这里如果后台传给我们的数据如果只是纯文本的话，我们就可能需要利用正则表达式去整个文本中去寻找需要着色的文本。相比于这种直接给出substring属性的的方式，用正则表达式可能解析起来更麻烦。关于正则表达式可参考链接 <a href="https://blog.csdn.net/crayondeng/article/details/16991579" target="_blank" rel="noopener">iOS正则表达式</a>这里不做赘述。本文采用解析json文件的方式进行绘制。</p>
</blockquote>
<p>先来看下Demo实现的效果</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr7895sclhj30cf0o5jt8.jpg" alt="QQ20180511-103712"></p>
<p>其中，点击图片部分会弹出图片大图浏览器，点击链接文字会跳转到指定的链接。</p>
<h3 id="示例程序关键代码解读"><a href="#示例程序关键代码解读" class="headerlink" title="示例程序关键代码解读"></a>示例程序关键代码解读</h3><p><code>CTFrameParserConfig</code>类:和上文一样，负责文本属性的全局配置</p>
<p><code>CTFrameParser</code>类：增加一个方法，让其可以从如上格式的模版文件中生成<code>CoreTextData</code>。最终我们的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;CoreTextData.h&quot;</span><br><span class="line"></span><br><span class="line">@interface CTFrameParser : NSObject</span><br><span class="line"></span><br><span class="line">+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig *)config;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CTFrameParser.h&quot;</span><br><span class="line">#import &quot;CoreTextData.h&quot;</span><br><span class="line">#import &quot;CTFrameParserConfig.h&quot;</span><br><span class="line">#import &quot;CoreTextImageData.h&quot;</span><br><span class="line">#import &quot;CoreTextLinkData.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation CTFrameParser</span><br><span class="line"></span><br><span class="line">// CTRun代理方法，获取当前run的上行高度</span><br><span class="line">static CGFloat ascentCallback(void *ref)&#123;</span><br><span class="line">    return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CTRun代理方法，获取当前run的下行高度</span><br><span class="line">static CGFloat descentCallback(void *ref)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CTRun代理方法，获取当前run的宽度</span><br><span class="line">static CGFloat widthCallback(void* ref)&#123;</span><br><span class="line">    return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line">//全局配置</span><br><span class="line">+ (NSMutableDictionary *)attributesWithConfig:(CTFrameParserConfig *)config &#123;</span><br><span class="line">    CGFloat fontSize = config.fontSize;</span><br><span class="line">    //创建字体 包括字形和大小</span><br><span class="line">    CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL);</span><br><span class="line">    //行高</span><br><span class="line">    CGFloat lineSpacing = config.lineSpace;</span><br><span class="line">    //段落属性</span><br><span class="line">    const CFIndex kNumberOfSettings = 3;</span><br><span class="line">    //创建段落属性的结构体数组 具体的段落属性值参考苹果官方文档</span><br><span class="line">    CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123;</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //创建段落属性</span><br><span class="line">    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings);</span><br><span class="line">    </span><br><span class="line">    UIColor * textColor = config.textColor;</span><br><span class="line">    //属性放入字典</span><br><span class="line">    NSMutableDictionary * dict = [NSMutableDictionary dictionary];</span><br><span class="line">    dict[(id)kCTForegroundColorAttributeName] = (id)textColor.CGColor;</span><br><span class="line">    dict[(id)kCTFontAttributeName] = (__bridge id)fontRef;</span><br><span class="line">    dict[(id)kCTParagraphStyleAttributeName] = (__bridge id)theParagraphRef;</span><br><span class="line">    //内存管理</span><br><span class="line">    CFRelease(theParagraphRef);</span><br><span class="line">    CFRelease(fontRef);</span><br><span class="line">    return dict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对外接口，传入json文件路径和全局配置，返回绘制需要的CoreTextData对象</span><br><span class="line">+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    //存放图片CoreTextImageData</span><br><span class="line">    NSMutableArray *imageArray = [NSMutableArray array];</span><br><span class="line">    //存放链接CoreTextImageData</span><br><span class="line">    NSMutableArray *linkArray = [NSMutableArray array];</span><br><span class="line">    //解析json文件，获取绘制需要的AttributedString</span><br><span class="line">    NSAttributedString *content = [self loadTemplateFile:path config:config</span><br><span class="line">                                              imageArray:imageArray linkArray:linkArray];</span><br><span class="line">    //根据AttributedString来创建CoreTextData</span><br><span class="line">    CoreTextData *data = [self parseAttributedContent:content config:config];</span><br><span class="line">    data.imageArray = imageArray;</span><br><span class="line">    data.linkArray = linkArray;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析json文件，获取绘制需要的AttributedString</span><br><span class="line">+ (NSAttributedString *)loadTemplateFile:(NSString *)path</span><br><span class="line">                                  config:(CTFrameParserConfig*)config</span><br><span class="line">                              imageArray:(NSMutableArray *)imageArray</span><br><span class="line">                               linkArray:(NSMutableArray *)linkArray &#123;</span><br><span class="line">    //json解析</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">    NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        NSArray *array = [NSJSONSerialization JSONObjectWithData:data</span><br><span class="line">                                                         options:NSJSONReadingAllowFragments</span><br><span class="line">                                                           error:nil];</span><br><span class="line">        if ([array isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (NSDictionary *dict in array) &#123;</span><br><span class="line">                NSString *type = dict[@&quot;type&quot;];</span><br><span class="line">                if ([type isEqualToString:@&quot;txt&quot;]) &#123;</span><br><span class="line">                    //纯文本的处理</span><br><span class="line">                    //此方法作用：1、内部首先会调用attributesWithConfig增加全局属性 2、根据解析结果给对应的文本增加Attribute</span><br><span class="line">                    NSAttributedString *as = [self parseAttributedContentFromNSDictionary:dict</span><br><span class="line">                                                                                   config:config];</span><br><span class="line">                    [result appendAttributedString:as];</span><br><span class="line">                &#125; else if ([type isEqualToString:@&quot;img&quot;]) &#123;</span><br><span class="line">                    //图片</span><br><span class="line">                    // 创建 CoreTextImageData用于存放图片属性</span><br><span class="line">                    CoreTextImageData *imageData = [[CoreTextImageData alloc] init];</span><br><span class="line">                    imageData.name = dict[@&quot;name&quot;];</span><br><span class="line">                    //result的长度即为图片的range.location</span><br><span class="line">                    imageData.position = [result length];</span><br><span class="line">                    [imageArray addObject:imageData];</span><br><span class="line">                    // 创建空白占位符，并且设置它的CTRunDelegate信息. 对于图片的排版，其实 CoreText 本质上不是直接支持的，但是，我们可以在要显示文本的地方，用一个特殊的空白字符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度信息，这样最后生成的CTFrame实例，就会在绘制时将图片的位置预留出来。</span><br><span class="line">                    //因为我们的CTDisplayView的绘制代码是在drawRect里面的，所以我们可以方便地把需要绘制的图片，用CGContextDrawImage方法直接绘制出来就可以了。</span><br><span class="line">                    //此处最终的返回字符串为与需要绘制图片同等大小的占位符（空白字符）</span><br><span class="line">                    NSAttributedString *as = [self parseImageDataFromNSDictionary:dict config:config];</span><br><span class="line">                    [result appendAttributedString:as];</span><br><span class="line">                &#125; else if ([type isEqualToString:@&quot;link&quot;]) &#123;</span><br><span class="line">                    //链接处理</span><br><span class="line">                    //链接开始位置的index为拼接之前的长度</span><br><span class="line">                    NSUInteger startPos = result.length;</span><br><span class="line">                    //同纯文本处理方式</span><br><span class="line">                    NSAttributedString *as = [self parseAttributedContentFromNSDictionary:dict</span><br><span class="line">                                                                                   config:config];</span><br><span class="line">                    [result appendAttributedString:as];</span><br><span class="line">                    // 创建 CoreTextLinkData</span><br><span class="line">                    NSUInteger length = result.length - startPos;</span><br><span class="line">                    //计算出链接在整个文本中的Range保存到linkData中，目的是方便判断点击位置是否在链接的范围内，在的话则跳转对应的链接。</span><br><span class="line">                    NSRange linkRange = NSMakeRange(startPos, length);</span><br><span class="line">                    CoreTextLinkData *linkData = [[CoreTextLinkData alloc] init];</span><br><span class="line">                    linkData.title = dict[@&quot;content&quot;];</span><br><span class="line">                    linkData.url = dict[@&quot;url&quot;];</span><br><span class="line">                    linkData.range = linkRange;</span><br><span class="line">                    [linkArray addObject:linkData];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析图片数据，设置CTRun的代理。（图文混排核心内容）</span><br><span class="line">+ (NSAttributedString *)parseImageDataFromNSDictionary:(NSDictionary *)dict</span><br><span class="line">                                                config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    //结构体类型，其中包含了CTRun的所有回调函数</span><br><span class="line">    CTRunDelegateCallbacks callbacks;</span><br><span class="line">    //给结构体分配内存空间</span><br><span class="line">    memset(&amp;callbacks, 0, sizeof(CTRunDelegateCallbacks));</span><br><span class="line">    //文档解释为 This field should always be set to kCTRunDelegateCurrentVersion. 传入kCTRunDelegateVersion1即可 （kCTRunDelegateCurrentVersion = kCTRunDelegateVersion1）</span><br><span class="line">    callbacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    //设置获取文字上行高度的回调方法</span><br><span class="line">    callbacks.getAscent = ascentCallback;</span><br><span class="line">    //设置获取文字下行高度的回调方法</span><br><span class="line">    callbacks.getDescent = descentCallback;</span><br><span class="line">    //设置获取文字宽度的回调方法</span><br><span class="line">    callbacks.getWidth = widthCallback;</span><br><span class="line">    //创建代理，传入回调方法结构体。第二个参数可以随便填写我们需要传入的数据，注意类型为void *</span><br><span class="line">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callbacks, (__bridge void *)(dict));</span><br><span class="line">    </span><br><span class="line">    // 使用0xFFFC作为空白的占位符</span><br><span class="line">    unichar objectReplacementChar = 0xFFFC;</span><br><span class="line">    NSString * content = [NSString stringWithCharacters:&amp;objectReplacementChar length:1];</span><br><span class="line">    NSDictionary * attributes = [self attributesWithConfig:config];</span><br><span class="line">    //给字符添加全局属性</span><br><span class="line">    NSMutableAttributedString * space = [[NSMutableAttributedString alloc] initWithString:content</span><br><span class="line">                                                                               attributes:attributes];</span><br><span class="line">    //设置代理</span><br><span class="line">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)space, CFRangeMake(0, 1),</span><br><span class="line">                                   kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    //内存管理</span><br><span class="line">    CFRelease(delegate);</span><br><span class="line">    return space;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析原始数据，返回AttributedString</span><br><span class="line">+ (NSAttributedString *)parseAttributedContentFromNSDictionary:(NSDictionary *)dict</span><br><span class="line">                                                        config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    //增加全局属性</span><br><span class="line">    NSMutableDictionary *attributes = [self attributesWithConfig:config];</span><br><span class="line">    </span><br><span class="line">    // 以下为增加自定义属性</span><br><span class="line">    </span><br><span class="line">    //根据字典的key值返回对应的颜色</span><br><span class="line">    UIColor *color = [self colorFromTemplate:dict[@&quot;color&quot;]];</span><br><span class="line">    if (color) &#123;</span><br><span class="line">        attributes[(id)kCTForegroundColorAttributeName] = (id)color.CGColor;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置字体大小</span><br><span class="line">    CGFloat fontSize = [dict[@&quot;size&quot;] floatValue];</span><br><span class="line">    if (fontSize &gt; 0) &#123;</span><br><span class="line">        //创建字体对象，包含了字形和字体大小</span><br><span class="line">        CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL);</span><br><span class="line">        attributes[(id)kCTFontAttributeName] = (__bridge id)fontRef;</span><br><span class="line">        CFRelease(fontRef);</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *content = dict[@&quot;content&quot;];</span><br><span class="line">    //返回经过自定义需要局部处理的字符串</span><br><span class="line">    return [[NSAttributedString alloc] initWithString:content attributes:attributes];</span><br><span class="line">&#125;</span><br><span class="line">//根据字典的key值返回对应的颜色</span><br><span class="line">+ (UIColor *)colorFromTemplate:(NSString *)name &#123;</span><br><span class="line">    if ([name isEqualToString:@&quot;blue&quot;]) &#123;</span><br><span class="line">        return [UIColor blueColor];</span><br><span class="line">    &#125; else if ([name isEqualToString:@&quot;red&quot;]) &#123;</span><br><span class="line">        return [UIColor redColor];</span><br><span class="line">    &#125; else if ([name isEqualToString:@&quot;black&quot;]) &#123;</span><br><span class="line">        return [UIColor blackColor];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据之前解析出来的AttributedString创建绘制所需要的CoreTextData</span><br><span class="line">+ (CoreTextData *)parseAttributedContent:(NSAttributedString *)content config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    // 创建CTFramesetterRef实例</span><br><span class="line">    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)content);</span><br><span class="line">    </span><br><span class="line">    // 获得要绘制的区域的高度</span><br><span class="line">    CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX);</span><br><span class="line">    //第二个参数表示文本范围，CFRangeMake(0,0)代表整个文本</span><br><span class="line">    CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil);</span><br><span class="line">    CGFloat textHeight = coreTextSize.height;</span><br><span class="line">    </span><br><span class="line">    // 生成CTFrameRef实例</span><br><span class="line">    CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight];</span><br><span class="line">    </span><br><span class="line">    // 将生成好的CTFrameRef实例和计算好的缓制高度保存到CoreTextData实例中，最后返回CoreTextData实例</span><br><span class="line">    CoreTextData *data = [[CoreTextData alloc] init];</span><br><span class="line">    data.ctFrame = frame;</span><br><span class="line">    data.height = textHeight;</span><br><span class="line">    data.content = content;</span><br><span class="line">    </span><br><span class="line">    // 释放内存</span><br><span class="line">    CFRelease(frame);</span><br><span class="line">    CFRelease(framesetter);</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建CTFrameRef实例</span><br><span class="line">+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter</span><br><span class="line">                                  config:(CTFrameParserConfig *)config</span><br><span class="line">                                  height:(CGFloat)height &#123;</span><br><span class="line">    //画布的路径（轮廓或者范围）</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height));</span><br><span class="line">    //最终生成绘制需要的frame，第二个参数表示文本范围，CFRangeMake(0,0)代表整个文本，最后一个参数为开发者自定义额外的属性，不需要填NULL即可。</span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL);</span><br><span class="line">    CFRelease(path);</span><br><span class="line">    return frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>CoreTextData</code>类：增加两个可变数分别用来存放文本中的图片和链接,在设置<code>imageArray</code>成员时，我们还会调一个新创建的<code>fillImagePosition</code>方法，用于找到每张图片在绘制时的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;CTFrameParserConfig.h&quot;</span><br><span class="line">#import &lt;CoreText/CoreText.h&gt;</span><br><span class="line"></span><br><span class="line">@interface CoreTextData : NSObject</span><br><span class="line">//绘制需要的CTFrameRef实例</span><br><span class="line">@property (assign, nonatomic) CTFrameRef ctFrame;</span><br><span class="line">//高度</span><br><span class="line">@property (assign, nonatomic) CGFloat height;</span><br><span class="line">//图片信息</span><br><span class="line">@property (strong, nonatomic) NSArray * imageArray;</span><br><span class="line">//链接信息</span><br><span class="line">@property (strong, nonatomic) NSArray * linkArray;</span><br><span class="line">//文本</span><br><span class="line">@property (strong, nonatomic) NSAttributedString *content;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CoreTextData.h&quot;</span><br><span class="line">#import &quot;CoreTextImageData.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation CoreTextData</span><br><span class="line">// CTFrameRef 属于CoreText框架，需要自己手动管理内存。ARC机制在此不在适用，所以需要重写Settter</span><br><span class="line">- (void)setCtFrame:(CTFrameRef)ctFrame &#123;</span><br><span class="line">    if (_ctFrame != ctFrame) &#123;</span><br><span class="line">        if (_ctFrame != nil) &#123;</span><br><span class="line">            CFRelease(_ctFrame);</span><br><span class="line">        &#125;</span><br><span class="line">        CFRetain(ctFrame);</span><br><span class="line">        _ctFrame = ctFrame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    if (_ctFrame != nil) &#123;</span><br><span class="line">        CFRelease(_ctFrame);</span><br><span class="line">        _ctFrame = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setImageArray:(NSArray *)imageArray &#123;</span><br><span class="line">    _imageArray = imageArray;</span><br><span class="line">    [self fillImagePosition];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算所有图片的位置和尺寸</span><br><span class="line">- (void)fillImagePosition &#123;</span><br><span class="line">    if (self.imageArray.count == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取所有CTLine对象</span><br><span class="line">    NSArray *lines = (NSArray *)CTFrameGetLines(self.ctFrame);</span><br><span class="line">    NSUInteger lineCount = [lines count];</span><br><span class="line">    // 每个CTLine对应的origin</span><br><span class="line">    CGPoint lineOrigins[lineCount];</span><br><span class="line">    // 获取所有origin，第二个参数传入文本的范围，CFRangeMake(0, 0)代表整个CTFrame的范围</span><br><span class="line">    CTFrameGetLineOrigins(self.ctFrame, CFRangeMake(0, 0), lineOrigins);</span><br><span class="line">    </span><br><span class="line">    int imgIndex = 0;</span><br><span class="line">    CoreTextImageData * imageData = self.imageArray[0];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; lineCount; ++i) &#123;</span><br><span class="line">        if (imageData == nil) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前第 i个 CTLine</span><br><span class="line">        CTLineRef line = (__bridge CTLineRef)lines[i];</span><br><span class="line">        // 获取line当中所有的CTRun对象</span><br><span class="line">        NSArray * runObjArray = (NSArray *)CTLineGetGlyphRuns(line);</span><br><span class="line">        //遍历所有的CTRun对象</span><br><span class="line">        for (id runObj in runObjArray) &#123;</span><br><span class="line">            CTRunRef run = (__bridge CTRunRef)runObj;</span><br><span class="line">            // 获取当前CTRun对象的Attributes</span><br><span class="line">            NSDictionary *runAttributes = (NSDictionary *)CTRunGetAttributes(run);</span><br><span class="line">            // 获取当前CTRun的代理 （因为代理方法中传入了我们需要的图片位置字典）</span><br><span class="line">            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(id)kCTRunDelegateAttributeName];</span><br><span class="line">            if (delegate == nil) &#123;</span><br><span class="line">                //判断代理是否存在，不存在则说明当前CTRun不是图片，继续循环查找下一个，存在则继续获取CTRun的各属性值</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //metDic为CTFrameParser类中解析图片时传入代理的参数</span><br><span class="line">            NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">            if (![metaDic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            CGRect runBounds;</span><br><span class="line">            CGFloat ascent;</span><br><span class="line">            CGFloat descent;</span><br><span class="line">            //CTRunGetTypographicBounds:获取CTRun的参数，第二个Range传入CFRangeMake(0, 0)表示整个CTRun</span><br><span class="line">            runBounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">            //CTRun的高度则为上行高度 + 下行高度，各常用属性详解参考文章</span><br><span class="line">            runBounds.size.height = ascent + descent;</span><br><span class="line">            //CTLineGetOffsetForStringIndex 获取特定Index处字符的偏移量</span><br><span class="line">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">            // CTRun（图片）的横坐标位置为 基础原点(Origin)的x + 偏移量</span><br><span class="line">            runBounds.origin.x = lineOrigins[i].x + xOffset;</span><br><span class="line">            runBounds.origin.y = lineOrigins[i].y;</span><br><span class="line">            //纵坐标为基础原点(Origin)的y值 - 下行高度 （目的是保证图片底部和文字的最底部对齐。也可以不减去descent，此时图片的底部和文字的基线(baseline) 对齐）</span><br><span class="line">            runBounds.origin.y -= descent;</span><br><span class="line">            // 获取当前CTFrame的路径</span><br><span class="line">            CGPathRef pathRef = CTFrameGetPath(self.ctFrame);</span><br><span class="line">            //获取路径的尺寸</span><br><span class="line">            CGRect colRect = CGPathGetBoundingBox(pathRef);</span><br><span class="line">            //相对父视图进行偏移，获取图片相对坐标系的位置</span><br><span class="line">            CGRect delegateBounds = CGRectOffset(runBounds, colRect.origin.x, colRect.origin.y);</span><br><span class="line">            imageData.imagePosition = delegateBounds;</span><br><span class="line">            imgIndex++;</span><br><span class="line">            if (imgIndex == self.imageArray.count) &#123;</span><br><span class="line">                imageData = nil;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                imageData = self.imageArray[imgIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>CoreTextUtils</code>新增类，主要的方法是使用 CTLineGetStringIndexForPosition 函数来获得用户点击的位置与 NSAttributedString 字符串上的位置的对应关系。这样就知道是点击的哪个字符了。然后判断该字符串是否在链接上即可。该 Util 在实现逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;CoreTextLinkData.h&quot;</span><br><span class="line">#import &quot;CoreTextData.h&quot;</span><br><span class="line"></span><br><span class="line">@interface CoreTextUtils : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 获取点击处CoreTextLinkData，如果点击的不是链接，返回空</span><br><span class="line"></span><br><span class="line"> @param view 当前点击所在的View</span><br><span class="line"> @param point 点击位置</span><br><span class="line"> @param data 当前文本信息</span><br><span class="line"> @return 获取点击处CoreTextLinkData，如果点击的不是链接，返回空</span><br><span class="line"> */</span><br><span class="line">+ (CoreTextLinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> @param view 点击所在View</span><br><span class="line"> @param point 点击位置</span><br><span class="line"> @param data 当前文本信息</span><br><span class="line"> @return 点击字符处的index</span><br><span class="line"> */</span><br><span class="line">+ (CFIndex)touchContentOffsetInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CoreTextUtils.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation CoreTextUtils</span><br><span class="line"></span><br><span class="line">// 检测点击位置是否在链接上</span><br><span class="line">+ (CoreTextLinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data &#123;</span><br><span class="line">    //将点击的位置转换成字符串的偏移量</span><br><span class="line">    CFIndex idx = [self touchContentOffsetInView:view atPoint:point data:data];</span><br><span class="line">    if (idx == -1) &#123;</span><br><span class="line">        //不在文本上</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果能找到点击处的index，则执行对link的遍历，查看index是否在link的Range范围之内</span><br><span class="line">    CoreTextLinkData * foundLink = [self linkAtIndex:idx linkArray:data.linkArray];</span><br><span class="line">    return foundLink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将点击的位置转换成字符串的偏移量，如果没有找到，则返回-1</span><br><span class="line">+ (CFIndex)touchContentOffsetInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data &#123;</span><br><span class="line">    //获取当前的CTFrameRef实例</span><br><span class="line">    CTFrameRef textFrame = data.ctFrame;</span><br><span class="line">    //获取每一行</span><br><span class="line">    CFArrayRef lines = CTFrameGetLines(textFrame);</span><br><span class="line">    if (!lines) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取总共的行数</span><br><span class="line">    CFIndex count = CFArrayGetCount(lines);</span><br><span class="line">    </span><br><span class="line">    // 获得每一行的origin坐标</span><br><span class="line">    CGPoint origins[count];</span><br><span class="line">    CTFrameGetLineOrigins(textFrame, CFRangeMake(0,0), origins);</span><br><span class="line">    </span><br><span class="line">    // 翻转坐标系</span><br><span class="line">    CGAffineTransform transform =  CGAffineTransformMakeTranslation(0, view.bounds.size.height);</span><br><span class="line">    transform = CGAffineTransformScale(transform, 1.f, -1.f);</span><br><span class="line">    </span><br><span class="line">    CFIndex idx = -1;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        CGPoint linePoint = origins[i];</span><br><span class="line">        CTLineRef line = CFArrayGetValueAtIndex(lines, i);</span><br><span class="line">        // 获得每一行的CGRect信息</span><br><span class="line">        CGRect flippedRect = [self getLineBounds:line point:linePoint];</span><br><span class="line">        CGRect rect = CGRectApplyAffineTransform(flippedRect, transform);</span><br><span class="line">        //如果点击处在当前行的范围之内</span><br><span class="line">        if (CGRectContainsPoint(rect, point)) &#123;</span><br><span class="line">            // 将点击的坐标转换成相对于当前行的坐标</span><br><span class="line">            CGPoint relativePoint = CGPointMake(point.x-CGRectGetMinX(rect),</span><br><span class="line">                                                point.y-CGRectGetMinY(rect));</span><br><span class="line">            // 获得当前点击坐标对应的字符串偏移，这里特别注意，第二个参数是相对当前行的坐标，不是相对整个frame坐标，故需要之前的转换</span><br><span class="line">            idx = CTLineGetStringIndexForPosition(line, relativePoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取当前行的位置和尺寸，注意这里的返回的坐标都是CoreText坐标，和UIKit的坐标系不同</span><br><span class="line">+ (CGRect)getLineBounds:(CTLineRef)line point:(CGPoint)point &#123;</span><br><span class="line">    CGFloat ascent = 0.0f;</span><br><span class="line">    CGFloat descent = 0.0f;</span><br><span class="line">    CGFloat leading = 0.0f;</span><br><span class="line">    //后面三个参数分别为上行高度、下行高度、行间距的地址</span><br><span class="line">    CGFloat width = (CGFloat)CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;leading);</span><br><span class="line">    CGFloat height = ascent + descent;</span><br><span class="line">    return CGRectMake(point.x, point.y - descent, width, height);</span><br><span class="line">&#125;</span><br><span class="line">//遍历linkArray，查看点击处是否在link的Range范围之内</span><br><span class="line">+ (CoreTextLinkData *)linkAtIndex:(CFIndex)i linkArray:(NSArray *)linkArray &#123;</span><br><span class="line">    CoreTextLinkData *link = nil;</span><br><span class="line">    for (CoreTextLinkData *data in linkArray) &#123;</span><br><span class="line">        if (NSLocationInRange(i, data.range)) &#123;</span><br><span class="line">            link = data;</span><br><span class="line">            //找到之后直接跳出循环，没有则返回空</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return link;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>CTDisplayView</code>添加对图片点击的支持，我们需要给<code>CTDisplayView</code>类增加用户点击操作的检测函数，在检测函数中，判断当前用户点击的区域是否在图片上，如果在图片上，则触发点击图片的逻辑。苹果提供的<code>UITapGestureRecognizer</code>可以很好的满足我们的要求，所以我们这里用它来检测用户的点击操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    self = [super initWithCoder:aDecoder];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self setupEvents];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setupEvents &#123;</span><br><span class="line">    UIGestureRecognizer * tapRecognizer =</span><br><span class="line">          [[UITapGestureRecognizer alloc] initWithTarget:self</span><br><span class="line">                    action:@selector(userTapGestureDetected:)];</span><br><span class="line">    tapRecognizer.delegate = self;</span><br><span class="line">    [self addGestureRecognizer:tapRecognizer];</span><br><span class="line">    self.userInteractionEnabled = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后增加<code>UITapGestureRecognizer</code>的回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//点击View时调用</span><br><span class="line">- (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer &#123;</span><br><span class="line">    //获取点击处的位置</span><br><span class="line">    CGPoint point = [recognizer locationInView:self];</span><br><span class="line">    //遍历imageArray，判断点击处是否在图片的Rect范围之内</span><br><span class="line">    for (CoreTextImageData * imageData in self.data.imageArray) &#123;</span><br><span class="line">        // 翻转坐标系，因为imageData中的坐标是CoreText的坐标系</span><br><span class="line">        CGRect imageRect = imageData.imagePosition;</span><br><span class="line">        CGPoint imagePosition = imageRect.origin;</span><br><span class="line">        //此处为计算在UIKit坐标系中图片原点的纵坐标，比较抽象，可画图理解下</span><br><span class="line">        imagePosition.y = self.bounds.size.height - imageRect.origin.y - imageRect.size.height;</span><br><span class="line">        //这个Rect是CoreText坐标转换后的UIKit坐标</span><br><span class="line">        CGRect rect = CGRectMake(imagePosition.x, imagePosition.y, imageRect.size.width, imageRect.size.height);</span><br><span class="line">        // 检测点击位置 Point 是否在rect之内</span><br><span class="line">        if (CGRectContainsPoint(rect, point)) &#123;</span><br><span class="line">            NSLog(@&quot;hit image&quot;);</span><br><span class="line">            // 在这里处理点击后的逻辑</span><br><span class="line">            NSDictionary *userInfo = @&#123; @&quot;imageData&quot;: imageData &#125;;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:CTDisplayViewImagePressedNotification</span><br><span class="line">                                                                object:self userInfo:userInfo];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //代码到此处说明点击处不在图片上，下一步检查是否在链接上</span><br><span class="line">    //返回为空的话说明不在，这里不进行处理点击事件，有返回值则发送通知消息给Controller，执行跳转操作</span><br><span class="line">    CoreTextLinkData *linkData = [CoreTextUtils touchLinkInView:self atPoint:point data:self.data];</span><br><span class="line">    if (linkData) &#123;</span><br><span class="line">         NSDictionary *userInfo = @&#123; @&quot;linkData&quot;: linkData &#125;;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:CTDisplayViewLinkPressedNotification</span><br><span class="line">                                                            object:self userInfo:userInfo];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在界面上，<code>CTDisplayView</code>通常在<code>UIView</code>的树形层级结构中，一个 UIView 可能是最外层 View Controller 的 View 的孩子的孩子的孩子（如下图所示）。在这种多级层次结构中，很难通过<code>delegate</code>模式将图片点击的事件一层一层往外层传递，所以最好使用<code>NSNotification</code>，来处理图片点击事件。</p>
</blockquote>
<p>至此，一个包含了特殊文字处理、图片、链接点击的图文混排程序已经基本实现了。其他细节部分比如图片浏览器，web浏览器、点击图片、链接处理详情等部分比较简单，参考Demo实现即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/编辑器和服务器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/编辑器和服务器/" itemprop="url">编辑器和服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux学习总结/" itemprop="url" rel="index">
                    <span itemprop="name">Linux学习总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="gedit编辑器"><a href="#gedit编辑器" class="headerlink" title="gedit编辑器"></a>gedit编辑器</h1><p>gedit是一个Linux环境下的文本编辑器，类似windows下的写字板程序，在不需要特别复杂的编程环境下，作为基本的文本编辑器比较合适。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fsiussiigzj30o10c1wim.jpg" alt="图片 1"></p>
<h1 id="sublime编辑器"><a href="#sublime编辑器" class="headerlink" title="sublime编辑器"></a>sublime编辑器</h1><p>Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用） 。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。 具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。</p>
<h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><ul>
<li>保存后从圆点编程叉，这样才是保存成功，保存命令：Ctrl + s</li>
<li>缩进按tab键，回退回来shift + tab</li>
<li>替换内容：选中要替换的内容ctrl+d输入你要修改的内容</li>
<li>Ctrl +  enter   光标所在行的下一行插入新行</li>
<li>Ctrl + shift  + enter  光标所在行的上一行插入新行</li>
<li>Ctrl  +  left/right    向左右单位性移动光标</li>
<li>shift +  up/down   选中多行</li>
<li>Ctrl  +  /  将光标所在行注释</li>
<li>Ctrl  +  shift  +  /  多行注释</li>
<li>Ctrl  +  ku   将选中处换为大写</li>
<li>Ctrl  +  kl   将选中处换为小写</li>
<li>Ctrl  +  Z  撤销</li>
<li>Ctrl  +  F  查找关键字</li>
<li>Ctrl  +  G 查找某行</li>
<li>Ctrl   +  M   光标移到括号内容的头或尾处</li>
<li>Ctrl+Shift+K 删除整行。</li>
</ul>
<h1 id="编辑器之神-vim"><a href="#编辑器之神-vim" class="headerlink" title="编辑器之神 -vim"></a>编辑器之神 -vim</h1><h2 id="vi简介"><a href="#vi简介" class="headerlink" title="vi简介"></a>vi简介</h2><p>vi是“Visual interface”的简称，它在Linux上的地位就仿佛Edit程序在DOS上一样。它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制。Vi不是一个排版程序，它不象Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。</p>
<p>三种工作模式：</p>
<blockquote>
<p> 命令模式</p>
<p>文本输入模式</p>
<p>末行模式</p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fsiv7mcvk6j30nz0ab0tv.jpg" alt="图片 1"></p>
<h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><p>任何时候，不管用户处于何种模式，只要按一下ESC键，即可使Vi进入命令模式；我们在shell环境(提示符为$)下输入启动Vi命令，进入编辑器时，也是处于该模式下。在该模式下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合法命令，Vi会响铃报警。</p>
<h2 id="文本输入模式"><a href="#文本输入模式" class="headerlink" title="文本输入模式"></a>文本输入模式</h2><p>在命令模式下输入插入命令i、附加命令a 、打开命令o、修改命令c、取代命令r或替换命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按键ESC即可。</p>
<h2 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h2><p>末行模式也称ex转义模式。在命令模式下，用户按“:”键即可进入末行模式下，此时Vi会在显示窗口的最后一行(通常也是屏幕的最后一行)显示一个“:”作为末行模式的提示符，等待用户输入命令。多数文件管理命令都是在此模式下执行的(如把编辑缓冲区的内容写到文件中等)。末行命令执行完后，Vi自动回到命令模式。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:sp newfile</span><br></pre></td></tr></table></figure>
<p>则分出一个窗口编辑newfile文件。如果要从命令模式转换到编辑模式，可以键入命令a或者i；如果需要从文本模式返回，则按Esc键即可。在命令模式下输入“:”即可切换到末行模式，然后输入命令。文件另存为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w newfile</span><br></pre></td></tr></table></figure>
<p>文件另存为newfile，当然当前文件也在，编辑的时候就是编辑的当前文件。</p>
<h2 id="vim基础操作"><a href="#vim基础操作" class="headerlink" title="vim基础操作"></a>vim基础操作</h2><p>vim是从 vi 发展出来的一个文本编辑器 。代码补完、编译及错误跳转等方便编程的功能特别丰富。Vi与vim的关系，它们都是多模式编辑器，不同的是vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面</p>
<h3 id="进入插入模式：ESC"><a href="#进入插入模式：ESC" class="headerlink" title="进入插入模式：ESC"></a>进入插入模式：ESC</h3><p>ESC：从插入模式或者末行模式进入命令模式</p>
<p>移动光标：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">h: 左移 </span><br><span class="line">j: 下移 </span><br><span class="line">k: 上移 </span><br><span class="line">l: 右移</span><br><span class="line">M：光标移动到中间行，屏幕的中间行</span><br><span class="line">L: 光标移动到屏幕最后一行行首 </span><br><span class="line">G: 移动到指定行,行号shift+g,例如：定位到第<span class="number">10</span>行：第一步<span class="number">10</span>，第二步shift+g</span><br><span class="line">如果shift+g:直接到文件最后一行行首</span><br><span class="line">w: 向后一次移动一个字 </span><br><span class="line">b: 向前一次移动一个字</span><br><span class="line">gg: 光标移动文件开头 </span><br><span class="line">G: 光标移动到文件末尾</span><br></pre></td></tr></table></figure>
<p>翻屏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctr-d: 向下翻半屏 </span><br><span class="line">Ctr-u: 向上翻半屏</span><br><span class="line">Ctr-f: 向下翻一屏 </span><br><span class="line">Ctr-b: 向上翻一屏</span><br></pre></td></tr></table></figure>
<h3 id="删除剪切命令"><a href="#删除剪切命令" class="headerlink" title="删除剪切命令"></a>删除剪切命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x: 删除光标后一个字符,相当于 Del </span><br><span class="line">X: 删除光标前一个字符,相当于 Backspace</span><br><span class="line">dd: 删除光标所在行,</span><br><span class="line">n dd 删除指定的行数 ，如果加上p就是剪切了</span><br><span class="line">D: 删除光标后本行所有内容,包含光标所在字符 </span><br><span class="line">d0: 删除光标前本行所有内容,不包含光标所在字符</span><br><span class="line">dw: 删除光标开始位置的字,包含光标所在字符</span><br></pre></td></tr></table></figure>
<h3 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u: 一步一步撤销 </span><br><span class="line">Ctr-r: 反撤销</span><br></pre></td></tr></table></figure>
<h3 id="文本行移动"><a href="#文本行移动" class="headerlink" title="文本行移动"></a>文本行移动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;: 文本行右移 </span><br><span class="line">&lt;&lt;: 文本行左移</span><br><span class="line">.：重复上一次操作的命令</span><br></pre></td></tr></table></figure>
<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yy：复制当前行，n yy：复制n行</span><br><span class="line">p：在光标所在的位置向下开辟新的一行，粘贴</span><br></pre></td></tr></table></figure>
<h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v: 按字符移动,选中文本 </span><br><span class="line">V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动</span><br></pre></td></tr></table></figure>
<h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r：替换当前字符</span><br><span class="line">R：替换当前字符，然后光标往后一个字符停留</span><br></pre></td></tr></table></figure>
<h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/：str查找</span><br><span class="line">n：下一个</span><br><span class="line">N：上一个</span><br></pre></td></tr></table></figure>
<h3 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把abc全部替换成123：</span><br><span class="line">1、进入末行模式：shift+：</span><br><span class="line">2、末行模式下，将光标所在行的abc替换成123：%s/abc/123/g</span><br><span class="line">3、末行模式下，将第1行至第10行之间的abc替换成123：1,10s/abc/123/g</span><br></pre></td></tr></table></figure>
<h3 id="保存并退出的三种方式"><a href="#保存并退出的三种方式" class="headerlink" title="保存并退出的三种方式"></a>保存并退出的三种方式</h3><ul>
<li>末行模式下：:x </li>
<li>末行模式下：:wq保存并且退出 </li>
<li>命令模式下：Shift+zz,（说明，这个键容易变成中英文输入法切换，要注意） </li>
</ul>
<h1 id="ubuntu软件安装与卸载"><a href="#ubuntu软件安装与卸载" class="headerlink" title="ubuntu软件安装与卸载"></a>ubuntu软件安装与卸载</h1><h2 id="更新Ubuntu软件下载地址"><a href="#更新Ubuntu软件下载地址" class="headerlink" title="更新Ubuntu软件下载地址"></a>更新Ubuntu软件下载地址</h2><ol>
<li><p>寻找国内镜像源：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a> 。所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的安卓市场；iOS手机上可以下载软件的AppStore </p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsix4bh2wzj30nz0cu0we.jpg" alt="图片 1"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsix4svnllj30nz0cu0vj.jpg" alt="图片 1"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsix5dbsz0j30nz0cuafb.jpg" alt="图片 1"></p>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fsix5yojd1j30nz0cun2k.jpg" alt="图片 1"></p>
<ol start="2">
<li><p>备份Ubuntu默认的源地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.<span class="built_in">list</span> /etc/apt/sources.<span class="built_in">list</span>.backup</span><br></pre></td></tr></table></figure>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsix78at0rj30o00gj45f.jpg" alt="图片 1"></p>
</li>
<li><p>更新源服务器列表</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsixeh9jsbj30o00gj45f.jpg" alt="图片 1"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fsixgifzy6j30o00gjqdh.jpg" alt="图片 1"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fsixgtz6vzj30o10gpgrl.jpg" alt="图片 1"></p>
</li>
<li><p>更新源</p>
<p>做完此步骤之后，就可以进行apt-get install 下载了 </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fsixiipjm4j30o00g6gpu.jpg" alt="图片 1"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsixj3ddhzj30o00g6woi.jpg" alt="图片 1"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsixjoklb5j30o00fzdqw.jpg" alt="图片 1"></p>
</li>
</ol>
<h2 id="Ubuntu软件操作的相关命令"><a href="#Ubuntu软件操作的相关命令" class="headerlink" title="Ubuntu软件操作的相关命令"></a>Ubuntu软件操作的相关命令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line"></span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line"></span><br><span class="line">sudo apt-get remove package 删除包</span><br><span class="line"></span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line"></span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line"></span><br><span class="line">sudo apt-get install package --reinstall   重新安装包</span><br><span class="line"></span><br><span class="line">sudo apt-get -f install   修复安装</span><br><span class="line"></span><br><span class="line">sudo apt-get remove package --purge 删除包，包括配置文件等</span><br><span class="line"></span><br><span class="line">sudo apt-get build-dep package 安装相关的编译环境</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br><span class="line"></span><br><span class="line">sudo apt-get dist-upgrade 升级系统</span><br><span class="line"></span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line"></span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line"></span><br><span class="line">sudo apt-get source package  下载该包的源代码</span><br><span class="line"></span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</span><br><span class="line"></span><br><span class="line">sudo apt-get check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>
<h1 id="Linux常用服务器构建-samba"><a href="#Linux常用服务器构建-samba" class="headerlink" title="Linux常用服务器构建-samba"></a>Linux常用服务器构建-samba</h1><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，能够完成在windows、mac操作系统下访问linux系统下的共享文件 。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用apt命令安装samba ：<code>sudo apt-get install samba samba-common</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsixmui1ijj30o00ftdqg.jpg" alt="图片 1"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li><p>创建存放共享文件的路径 :</p>
<ul>
<li><p>在home路径下输入命令 <code>touch share</code></p>
</li>
<li><p>修改其权限：<code>chmod 777 share</code></p>
</li>
<li><p>修改samba的配置文件：<code>vi /etc/samba/smb.conf</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsixrv358sj30nz0ioago.jpg" alt="图片 1"></p>
</li>
</ul>
</li>
<li><p>创建samba账户–如果要设置密码的话设置这步 </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsixtdi6ggj30nz02f3z2.jpg" alt="图片 1"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsixtshwefj30o003lgn9.jpg" alt="图片 1"></p>
</li>
</ol>
<h2 id="启动samba"><a href="#启动samba" class="headerlink" title="启动samba"></a>启动samba</h2><p>启动：<code>sudo system-config-samba</code>。当对配置进行了更新，需要重启samba软件后才能生效。重启命令：<code>/etc/init.d/smbd restart</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsixx3hceyj30o10en77i.jpg" alt="图片 1"></p>
<h2 id="访问共享文件"><a href="#访问共享文件" class="headerlink" title="访问共享文件"></a>访问共享文件</h2><h3 id="windows下访问方式"><a href="#windows下访问方式" class="headerlink" title="windows下访问方式"></a>windows下访问方式</h3><p>  快捷键：Win + r ，然后输入你的Linux系统的IP地址 例如：\\192.168.31.28</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fsixzpwehaj30ij0bcq4u.jpg" alt="图片 1"></p>
<p>之后会输入框，输入Linux系统账号和密码 即可链接。链接之后可以对linux目录进行读写</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fsiy1sdthoj30o00etq5z.jpg" alt="图片 1"></p>
<h3 id="macOS下访问方式"><a href="#macOS下访问方式" class="headerlink" title="macOS下访问方式"></a>macOS下访问方式</h3><ol>
<li><p>cmd + k</p>
</li>
<li><p>输入smb:// + IP</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fsiy37tjznj30dl06fjrp.jpg" alt="屏幕快照 2018-06-21 下午5.49.13"></p>
</li>
<li><p>点击注册用户，输入用户名和密码即可</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsiy4ucgw5j30o00gqjua.jpg" alt="图片 1"></p>
</li>
</ol>
<h1 id="Linux常用服务器构建-ssh"><a href="#Linux常用服务器构建-ssh" class="headerlink" title="Linux常用服务器构建-ssh"></a>Linux常用服务器构建-ssh</h1><h2 id="ssh介绍"><a href="#ssh介绍" class="headerlink" title="ssh介绍"></a>ssh介绍</h2><p>SSH为Secure Shell的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在<strong>应用层和传输层基础上的安全协议</strong>。</p>
<p>SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。<strong>常用于远程登录</strong>，<strong>以及用户之间进行资料拷贝。</strong></p>
<p>利用SSH协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、<strong>Linux</strong>、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。</p>
<p>使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。</p>
<h2 id="在linux服务器安装ssh"><a href="#在linux服务器安装ssh" class="headerlink" title="在linux服务器安装ssh"></a>在linux服务器安装ssh</h2><p>安装命令：<code>sudo apt-get install openssh-server</code></p>
<h3 id="windows下ssh连接服务器"><a href="#windows下ssh连接服务器" class="headerlink" title="windows下ssh连接服务器"></a>windows下ssh连接服务器</h3><p>安装软件Xshell 5</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fsiyc7j2hbj30o10ktq6k.jpg" alt="图片 1"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsiyco3zbij30o10iz0xy.jpg" alt="图片 1"></p>
<h3 id="macOS下ssh连接服务器"><a href="#macOS下ssh连接服务器" class="headerlink" title="macOS下ssh连接服务器"></a>macOS下ssh连接服务器</h3><p>从macOS或者linux系统客户机远程登陆linux系统服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@IP</span><br><span class="line">例如：ssh simplecoder@<span class="number">192.168</span><span class="number">.28</span><span class="number">.31</span></span><br></pre></td></tr></table></figure>
<p>使用ssh访问，如访问出现错误。可查看是否有该文件 ～/.ssh/known_ssh 尝试删除该文件解决 。SSH 告知用户，这个主机不能识别，这时键入”yes”，SSH 就会将相关信息，写入” ~/.ssh/know_hosts” 中，再次访问，就不会有这些信息了。然后输入完口令,就可以登录到主机了。 </p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsiyi1yhuvj30o10c414k.jpg" alt="图片 1"></p>
<h1 id="Linux常用服务器构建-ftp"><a href="#Linux常用服务器构建-ftp" class="headerlink" title="Linux常用服务器构建-ftp"></a>Linux常用服务器构建-ftp</h1><p>FTP 是File Transfer Protocol（<strong>文件传输协议</strong>）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。</p>
<p>在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fsiymz47qyj30nd08ljsb.jpg" alt="图片 1"></p>
<h2 id="安装vsftpd服务器"><a href="#安装vsftpd服务器" class="headerlink" title="安装vsftpd服务器"></a>安装vsftpd服务器</h2><ol>
<li><p>命令：<code>sudo apt-get install vsftpd</code></p>
</li>
<li><p>配置vsftpd.conf文件 : <code>sudo vi /etc/vsftpd.conf</code>。 </p>
<ul>
<li><p>不许匿名用户登录：<code>anonyous_enable=NO</code>注意NO是大写</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fsiyq300e6j30o10fktgx.jpg" alt="图片 1"></p>
</li>
<li><p>然后指定ftp上传下载目录</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsiys665rtj30o00egdna.jpg" alt="图片 1"></p>
</li>
<li><p>设置允许本机登录：<code>local_enable = YES</code></p>
</li>
<li><p>允许vsftpd.chroot_list文件中用户进程登录FTP服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chroot_list_enable=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br></pre></td></tr></table></figure>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fsiyw1ghmbj30o10ksgwu.jpg" alt="图片 1"></p>
</li>
<li><p>允许上传文件到FTP服务器:<code>write_enable=YES</code></p>
</li>
<li><p>配置用户信息 :<code>sudo vi /etc/vsftpd.chroot_list</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsiyydnrbuj30o10ehwi1.jpg" alt="图片 1"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fsiyytzkb3j30o10f8gnt.jpg" alt="图片 1"></p>
</li>
<li><p>修改文件拥有者权限只有xr</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsiz00uxy8j30o10hydqw.jpg" alt="图片 1"></p>
</li>
<li><p>创建share目录</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsiz0uqr40j30o00ehgp7.jpg" alt="图片 1"></p>
</li>
<li><p>重新启动FTP服务器:<code>sudo /etc/init.d/vsftpd restart</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsiz24xxbaj30o00f2tcv.jpg" alt="图片 1"></p>
</li>
</ul>
</li>
</ol>
<h2 id="在window上使用ftp客户端-FileZilla"><a href="#在window上使用ftp客户端-FileZilla" class="headerlink" title="在window上使用ftp客户端(FileZilla)"></a>在window上使用ftp客户端(FileZilla)</h2><h3 id="安装-amp-配置FileZilla"><a href="#安装-amp-配置FileZilla" class="headerlink" title="安装&amp;配置FileZilla"></a>安装&amp;配置FileZilla</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsiz4rjsdej30lu0gwq5p.jpg" alt="图片 1"></p>
<p>之后在配置界面输入主机IP、用户名、密码、端口号（ftp默认端口21）即可连接</p>
<h2 id="在macOS上使用命令删除和下载文件"><a href="#在macOS上使用命令删除和下载文件" class="headerlink" title="在macOS上使用命令删除和下载文件"></a>在macOS上使用命令删除和下载文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ftp IP	登录ftp服务器</span><br><span class="line">put somefile 上传文件</span><br><span class="line">get somefile 下载文件</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsiz9iwgfwj30o10gudje.jpg" alt="图片 1"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/深入了解代码块Block（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/深入了解代码块Block（一）/" itemprop="url">深入了解代码块（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发进阶/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发进阶</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="深入了解代码块Block"><a href="#深入了解代码块Block" class="headerlink" title="深入了解代码块Block"></a>深入了解代码块Block</h1><h2 id="1-基础回顾"><a href="#1-基础回顾" class="headerlink" title="1.基础回顾"></a>1.基础回顾</h2><p><code>Block</code>就是一个函数体（匿名函数），它是ObjC对于闭包的实现，在块状中我们可以持有或引用局部变量（不禁想到了lambda表达式），同时利用Block你可以将一个操作作为一个参数进行传递,类似于C语言中的函数指针。</p>
<ol>
<li>Block类型定义：<strong>返回值类型(^ 变量名)(参数列表)</strong>（注意Block也是一种类型）；</li>
<li>Block的typedef定义：<strong>返回值类型(^类型名称)(参数列表)</strong>；</li>
<li>Block的实现：<strong>^(参数列表){操作主体}</strong>；</li>
</ol>
<p>##2.Block底层数据结构</p>
<h3 id="首先从一个简单Block说起："><a href="#首先从一个简单Block说起：" class="headerlink" title="首先从一个简单Block说起："></a>首先从一个简单Block说起：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">void</span>(^block)() = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"this is block,age = %d"</span>,age);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令行将代码转化为c++查看其内部结构，与OC代码进行比较</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义代码中，可以发现，block定义中调用了<code>main_block_impl_0</code>函数，并且将<code>main_block_impl_0</code>函数的地址赋值给了<code>block</code>。那么我们来看一下<code>__main_block_impl_0</code>函数内部结构。</p>
<h3 id="main-block-impl-0"><a href="#main-block-impl-0" class="headerlink" title="__main_block_impl_0"></a>__main_block_impl_0</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>main_block_imp_0</code>结构体内有一个同名构造函数<code>main_block_imp_0</code>，构造函数中对一些变量进行了赋值最终会返回一个结构体。最终将一个<code>__main_block_imp_0</code>结构体的地址赋值给了block变量。</p>
<p><code>main_block_impl_0</code>结构体内可以发现<code>main_block_impl_0</code>构造函数中传入了四个参数。其中<code>flags</code>有默认值，也就说<code>flags</code>参数在调用的时候可以省略不传。而最后的 age(_age)则表示传入的_age参数会自动赋值给age成员，相当于age = _age。</p>
<p>接下来跳到<code>(void *)__main_block_func_0</code>函数的实现部分</p>
<h3 id="main-block-func-0"><a href="#main-block-func-0" class="headerlink" title="__main_block_func_0"></a>__main_block_func_0</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_m7_y_gtxjyx6mdckhrjrhn50plm0000gn_T_main_41049f_mi_1,age);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main_block_func_0</code>函数中首先取出<code>block</code>中<code>age</code>的值，紧接着可以看到两个熟悉的NSLog，可以发现这两段代码恰恰是我们在block块中写下的代码。<br> 那么<code>main_block_func_0</code>函数中其实存储着我们block中写下的代码。而<code>main_block_impl_0</code>函数中传入的是<code>(void *)main_block_func_0</code>，也就说将我们写在block块中的代码封装成<code>main_block_func_0</code>函数，并将<code>main_block_func_0</code>函数的地址传入了<code>__main_block_impl_0</code>的构造函数中保存在结构体内。</p>
<p>继续跳转函数<code>__main_block_desc_0_DATA</code>,观察其内部实现</p>
<h3 id="main-block-desc-0"><a href="#main-block-desc-0" class="headerlink" title="__main_block_desc_0"></a>__main_block_desc_0</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>main_block_desc_0</code>中存储着两个参数，<code>reserved</code>和<code>Block_size</code>，并且<code>reserved</code>赋值为0而<code>Block_size</code>则存储着<code>main_block_impl_0</code>的占用空间大小。最终将<code>main_block_desc_0</code>结构体的地址传入<code>main_block_func_0</code>中赋值给<code>Desc</code>。</p>
<h3 id="block-impl"><a href="#block-impl" class="headerlink" title="__block_impl"></a>__block_impl</h3><p>此时回过头来查看<code>__main_block_impl_0</code>结构体。第一个变量就是<code>__block_impl</code>结构体,<code>__block_impl</code>内部结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现<code>__block_impl</code>结构体内部就有一个isa指针。<strong>因此可以证明block本质上就是一个oc对象</strong>。而在构造函数中函数传入的值分别存储在main_block_impl_0结构体实例中，最终将结构体的地址赋值给block。</p>
<p>通过上面对<code>__main_block_impl_0</code>结构体构造函数三个参数的分析我们可以得出结论：</p>
<ul>
<li><p><code>__block_impl</code>结构体中isa指针存储着<code>&amp;_NSConcreteStackBlock</code>地址，可以暂时理解为其类对象地址，block就是<code>_NSConcreteStackBlock</code>类型的。</p>
</li>
<li><p>block代码块中的代码被封装成<code>main_block_func_0</code>函数，<code>FuncPtr</code>则存储着<code>main_block_func_0</code>函数的地址。</p>
</li>
<li><p><code>Desc</code>指向<code>main_block_desc_0</code>结构体对象，其中存储<code>main_block_impl_0</code>结构体所占用的内存。</p>
</li>
</ul>
<p>以下简单用一张图表示各个成员之间的关系</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwdj94numaj31130h0wiq.jpg" alt="图示block结构体内部之间的关系"></p>
<h2 id="3-变量捕获"><a href="#3-变量捕获" class="headerlink" title="3.变量捕获"></a>3.变量捕获</h2><p>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwdjhpo46cj30to05fq3u.jpg" alt="Block变量捕获"></p>
<p>下面通过示例程序一一了解上面这张表。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="auto（自动）变量"><a href="#auto（自动）变量" class="headerlink" title="auto（自动）变量"></a>auto（自动）变量</h4><p>还是以上面的代码为例，通过OC转C++的代码我们知道，在<code>struct __main_block_impl_0</code>结构体中，有一个<code>age</code>变量，根据C语言基础我们知道，变量如果没有加修饰符默认为<code>auto</code>（自动）变量，自动变量的特点是离开作用域就销毁。所以为了block能在适当的时刻访问到自动变量而不被系统销毁，必须让block保存一份自动变量，我们称之为”捕获”。当然其访问方式为值传递。</p>
<h4 id="static（静态）变量"><a href="#static（静态）变量" class="headerlink" title="static（静态）变量"></a>static（静态）变量</h4><p>static 修饰的变量为指针传递，同样会被block捕获。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        auto <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"hello, a = %d, b = %d"</span>, a,b);</span><br><span class="line">        &#125;;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// log : block本质[57465:18555229] hello, a = 10, b = 2</span></span><br><span class="line"><span class="comment">// block中a的值没有被改变而b的值随外部变化而变化。</span></span><br></pre></td></tr></table></figure>
<p>生成的C++代码：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwdjzttd3nj311h0kzgq6.jpg" alt="局部变量C++代码"></p>
<p>从上述源码中可以看出，a,b两个变量都有捕获到block内部。但是a传入的是值，而b传入的则是地址。</p>
<p>为什么两种变量会有这种差异呢，因为自动变量可能会销毁，block在执行的时候有可能自动变量已经被销毁了，那么此时如果再去访问被销毁的地址肯定会发生坏内存访问，因此对于自动变量一定是值传递而不可能是指针传递了。而静态变量不会被销毁，所以完全可以传递地址。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"hello, a = %d, b = %d"</span>, a,b);</span><br><span class="line">        &#125;;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// log hello, a = 1, b = 2</span></span><br></pre></td></tr></table></figure>
<p>上面的代码修改了全局变量a、b的值，发现总会作用于Block内部，所以并不会捕获全局变量。</p>
<p>这个不难理解，因为全局变量在整个程序运行的过程中随处都可以进行访问，因此Block内部无需再去保存一份。</p>
<p>同样的方式我们可以转成C++代码，发现实现内部确实没有a和b变量。很简单这里不再贴代码。</p>
<p>##4.Block类型</p>
<p>通过前几节的研究我们发现，Block的本质其实是一个封装了函数调用以及函数调用环境的OC对象。那么，block对象具体是什么类型的呢？下面我们就通过代码来窥探一下。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// __NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject</span></span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [block <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[block <span class="keyword">class</span>] superclass]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[block <span class="keyword">class</span>] superclass] superclass]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[[block <span class="keyword">class</span>] superclass] superclass] superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log：__NSGlobalBlock__</span><br><span class="line">     __NSGlobalBlock</span><br><span class="line">     <span class="built_in">NSBlock</span></span><br><span class="line">     <span class="built_in">NSObject</span></span><br></pre></td></tr></table></figure>
<p>从上述打印内容可以看出block最终都是继承自<code>NSBlock</code>类型，而<code>NSBlock</code>继承于<code>NSObjcet</code>。那么block其中的isa指针其实是来自NSObject中的。这也更加印证了block的本质其实就是OC对象。</p>
<h4 id="Block的三种类型"><a href="#Block的三种类型" class="headerlink" title="Block的三种类型"></a>Block的三种类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）</span><br><span class="line">__NSStackBlock__ （ _NSConcreteStackBlock ）</span><br><span class="line">__NSMallocBlock__ （ _NSConcreteMallocBlock ）</span><br></pre></td></tr></table></figure>
<p>那么，什么情况下对应以上各种不同类型的block呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 内部没有访问auto变量的block</span></span><br><span class="line">        <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 2. 内部访问auto变量的block</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">void</span> (^block2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Hello - %d"</span>,a);</span><br><span class="line">        &#125;;</span><br><span class="line">       <span class="comment">// 3. 直接调用的block的class</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@ %@"</span>, [block1 <span class="keyword">class</span>], [block2 <span class="keyword">class</span>], [^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br><span class="line">        &#125; <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">log：__NSGlobalBlock__，__NSMalocBlock__，__NSStackBlock__</span><br></pre></td></tr></table></figure>
<p>但是我们上面提到过，上述代码转化为c++代码查看源码时却发现block的类型与打印出来的类型不一样，c++源码中三个block的isa指针全部都指向<code>_NSConcreteStackBlock</code>类型地址。</p>
<p>我们可以猜测<code>runtime</code>运行时过程中也许对类型进行了转变。最终类型当然以<code>runtime</code>运行时类型也就是我们打印出的类型为准。</p>
<h4 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwdlo2pgrrj30b507tdh1.jpg" alt="不同类型的Block的存储区域"></p>
<p>上图中可以发现，根据block的类型不同，block存放在不同的区域中。<br> 数据段中的<code>__NSGlobalBlock__</code>直到程序结束才会被回收，不过我们很少使用到<code>__NSGlobalBlock__</code>类型的block，因为这样使用block并没有什么意义。</p>
<p><code>__NSStackBlock__</code>类型的block存放在栈中，我们知道栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放，而在相同的作用域中定义block并且调用block似乎也多此一举。</p>
<p><code>__NSMallocBlock__</code>是在平时编码过程中最常使用到的。存放在堆中需要我们自己进行内存管理。</p>
<p>下面这张表示不同状态下block对应的类型：</p>
<table>
<thead>
<tr>
<th>block类型</th>
<th>环境</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NSGlobalBlock</strong></td>
<td>没有访问auto变量</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>访问了auto变量</td>
</tr>
<tr>
<td><strong>NSMallocBlock</strong></td>
<td><strong>NSStackBlock</strong>调用了copy</td>
</tr>
</tbody>
</table>
<p>每一种类型的block调用copy后的结果如下所示</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwdm1d2h7mj30fk02wq44.jpg" alt="调用copy后的效果"></p>
<p>MRC环境下经常需要使用copy来保存block，将栈上的block拷贝到堆中，即使栈上的block被销毁，堆上的block也不会被销毁，需要我们自己调用release操作来销毁。</p>
<p>在ARC环境下，只要满足以下条件之一，栈上的block就会调用copy函数到堆上变成<code>NSMallocBlock</code>:</p>
<ul>
<li><p>block作为函数返回值时</p>
</li>
<li><p>将block赋值给__strong指针时</p>
</li>
<li><p>block作为Cocoa API中方法名含有usingBlock的方法参数时</p>
</li>
<li><p>block作为GCD API的方法参数时</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/UIStackView/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/UIStackView/" itemprop="url">UIStackView</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h2><h3 id="UIStackView是什么"><a href="#UIStackView是什么" class="headerlink" title="UIStackView是什么"></a>UIStackView是什么</h3><blockquote>
<p>A streamlined interface for laying out a collection of views in either a column or a row.<br>一个高效的接口用于平铺一行或一列的视图组合<br>iOS9中，苹果在UIKit框架中引入了一个新的视图类UIStackView。UIStackView内部管理者一个<strong>arrangedSubviews</strong>，这些arrangedSubviews会根据它们在数组中的顺序，按照UIStackView定义的轴向<strong>“axis”</strong>顺序排列。对于嵌入其中的子视图来讲，你无须去添加约束，stack view会自动处理好布局。</p>
</blockquote>
<h3 id="UIStackView的作用"><a href="#UIStackView的作用" class="headerlink" title="UIStackView的作用"></a>UIStackView的作用</h3><p>从一个简单布局示例说起：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq9r98ji2fj30bi0c9t8p.jpg" alt=""><br>在认识stack view 之前，我们能想到的最有效的方式是使用AutoLayout进行布局，对其中的每一个View各自添加约束。了解<strong>Masonry</strong>框架的话，可以使用其<a href="https://www.jianshu.com/p/2c7a5ba73fc2" target="_blank" rel="noopener"> 等间距布局</a>的方式简化操作流程。</p>
<p>如果使用UIStackView，其实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">containerView = [[UIStackView alloc] initWithFrame:CGRectMake(0, 100, ScreenWidth, 200)];</span><br><span class="line">containerView.axis = UILayoutConstraintAxisHorizontal;</span><br><span class="line">containerView.distribution = UIStackViewDistributionFillEqually;</span><br><span class="line">containerView.spacing = 10;</span><br><span class="line">containerView.alignment = UIStackViewAlignmentFill;</span><br></pre></td></tr></table></figure>
<p>简洁明了。</p>
<h3 id="UIStackView的常用属性和方法"><a href="#UIStackView的常用属性和方法" class="headerlink" title="UIStackView的常用属性和方法"></a>UIStackView的常用属性和方法</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq9r99f75kj30qc0ikmx0.jpg" alt=""></p>
<ol>
<li>axis ：子控件的布局方向，水平或垂直。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef enum UILayoutConstraintAxis : NSInteger &#123;</span><br><span class="line">    UILayoutConstraintAxisHorizontal = 0,</span><br><span class="line">    UILayoutConstraintAxisVertical = 1</span><br><span class="line">&#125; UILayoutConstraintAxis;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>spacing：之所以说是最小间距，因为stackView会根据一定的规则对内部空间布局，有的时候不能满足所有要求，比如stackView 本身宽度100，内部两个控件，宽度都为50，50+50+10就超过了本身宽度， 这时会压缩其中一个子控件的宽度来满足最小间距。</li>
</ol>
<blockquote>
<p>在弄懂压缩的优先级问题之前，有必要了解解一下什么是 Intrinsic Content Size。我们平时使用AutoLayout约束一个UILabel、UIImageView、或者UIButton的时候，经常只给定他们的位置（origin），控件内部的Size会自动计算出来“撑开”控件。这个撑开的尺寸就是 Intrinsic Content Size（固有尺寸）。UIStackView子控件布局就是根据固有尺寸来确定的，如果子控件的固有尺寸加上spacing的值大于了UIStackView的宽度（如果垂直布局则为高度），就会压缩其中的一个子控件，具体来讲压缩 CompressionResistance值较低的那个。详情参考 <a href="https://blog.csdn.net/deft_mkjing/article/details/51532057" target="_blank" rel="noopener">Hugging &amp; CompressionResistance</a></p>
</blockquote>
<ol start="3">
<li>distribution：子控件依据何种规则布局, UIStackViewDistribution枚举定义如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef enum UIStackViewDistribution : NSInteger &#123;</span><br><span class="line"></span><br><span class="line">    UIStackViewDistributionFill = 0,</span><br><span class="line"></span><br><span class="line">    UIStackViewDistributionFillEqually,</span><br><span class="line"></span><br><span class="line">    UIStackViewDistributionFillProportionally,</span><br><span class="line"></span><br><span class="line">    UIStackViewDistributionEqualSpacing,</span><br><span class="line"></span><br><span class="line">    UIStackViewDistributionEqualCentering</span><br><span class="line"></span><br><span class="line">&#125; UIStackViewDistribution;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>UIStackViewDistributionFill：它就是将 arrangedSubviews 填充满整个 StackView ，如果设置了spacing，那么这些 arrangedSubviews 之间的间距就是spacing。如果减去所有的spacing，所有的 arrangedSubview 的固有尺寸( intrinsicContentSize )不能填满或者超出 StackView 的尺寸，那就会按照 Hugging 或者 CompressionResistance 的优先级来拉伸或压缩一些 arrangedSubview 。如果出现优先级相同的情况，就按排列顺序来拉伸或压缩。</p>
<p>​</p>
</li>
<li><p>UIStackViewDistributionFillEqually：这种就是 StackView 的尺寸减去所有的spacing之后均分给 arrangedSubviews ，每个 arrangedSubview 的尺寸是相同的。</p>
<p>​</p>
</li>
<li><p>UIStackViewDistributionFillProportionally：这种跟FillEqually差不多，只不过这个不是讲尺寸均分给 arrangedSubviews ，而是根据 arrangedSubviews 的 intrinsicContentSize 按比例分配。</p>
<p>​</p>
</li>
<li><p>UIStackViewDistributionEqualSpacing：这种是使 arrangedSubview 之间的spacing相等，但是这个spacing是有可能大于 StackView 所设置的spacing，但是绝对不会小于。这个类型的布局可以这样理解，先按所有的 arrangedSubview 的 intrinsicContentSize 布局，然后余下的空间均分为spacing，如果大约 StackView 设置的spacing那这样就OK了，如果小于就按照 StackView 设置的spacing，然后按照 CompressionResistance 的优先级来压缩一个 arrangedSubview</p>
<p>​</p>
</li>
<li><p>UIStackViewDistributionEqualCentering：这种是使 arrangedSubview 的中心点之间的距离相等，这样没两个 arrangedSubview 之间的spacing就有可能不是相等的，但是这个spacing仍然是大于等于 StackView 设置的spacing的，不会是小于。这个类型布局仍然是如果 StackView 有多余的空间会均分给 arrangedSubviews 之间的spacing，如果空间不够那就按照 CompressionResistance 的优先级压缩 arrangedSubview</p>
</li>
</ul>
<ol start="4">
<li>alignment：子控件对其方式，类似UIlabel的textAlignment，是一个枚举值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef enum UIStackViewAlignment : NSInteger &#123;</span><br><span class="line">    UIStackViewAlignmentFill,</span><br><span class="line">    UIStackViewAlignmentLeading,</span><br><span class="line">    UIStackViewAlignmentTop = UIStackViewAlignmentLeading,</span><br><span class="line">    UIStackViewAlignmentFirstBaseline,</span><br><span class="line">    UIStackViewAlignmentCenter,</span><br><span class="line">    UIStackViewAlignmentTrailing,</span><br><span class="line">    UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing,</span><br><span class="line">    UIStackViewAlignmentLastBaseline</span><br><span class="line">&#125; UIStackViewAlignment;</span><br></pre></td></tr></table></figure>
<ul>
<li>UIStackViewAlignmentFill：默认方式， 如果子控件水平布局, 则指子控件的垂直方向填充满stackView. 反之亦然</li>
</ul>
<ul>
<li>UIStackViewAlignmentLeading：如果子控件竖直布局, 则指子控件左边对齐stackView左边. 反之亦然, 即 UIStackViewAlignmentTop = UIStackViewAlignmentLeading。</li>
</ul>
<ul>
<li><p>UIStackViewAlignmentTop = UIStackViewAlignmentLeading</p>
<p>​</p>
</li>
<li><p>UIStackViewAlignmentFirstBaseline：根据上方基线布局所有子视图的y值</p>
<p>​</p>
</li>
<li><p>UIStackViewAlignmentCenter：中心对齐</p>
<p>​</p>
</li>
<li><p>UIStackViewAlignmentTrailing：如果子控件竖直布局, 则指子控件左边对齐stackView右边. 反之亦然, 即UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing</p>
<p>​</p>
</li>
<li><p>UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing</p>
<p>​</p>
</li>
<li><p>UIStackViewAlignmentLastBaseline：根据下方基线布局所有子视图的y值</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/OC对象的本质窥探/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/OC对象的本质窥探/" itemprop="url">OC对象本质窥探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS进阶/" itemprop="url" rel="index">
                    <span itemprop="name">iOS进阶</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OC对象本质窥探"><a href="#OC对象本质窥探" class="headerlink" title="OC对象本质窥探"></a>OC对象本质窥探</h1><h2 id="从一道面试题说起"><a href="#从一道面试题说起" class="headerlink" title="从一道面试题说起"></a>从一道面试题说起</h2><blockquote>
<p>一个NSObject对象占用多少内存？</p>
</blockquote>
<p>要回答这道面试题，首先需要对OC对象的底层实现有一定的认识。目前已知的是：我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvzn8wtgguj31kw05et9p.jpg" alt="屏幕快照 2018-10-07 下午2.28.10"></p>
<p><strong>Objective-C的面向对象都是基于C\C++的数据结构实现的。</strong></p>
<p>那么问题来了：Objective-C的对象、类主要是基于C/C++的什么数据结构实现的？ 答案是结构体。要想证明这一点，我们可以尝试将OC代码转换为C/C++代码，以便我们进一步对OC对象本质的进一步探索。</p>
<h2 id="OC对象的本质"><a href="#OC对象的本质" class="headerlink" title="OC对象的本质"></a>OC对象的本质</h2><h4 id="OC代码转C-C"><a href="#OC代码转C-C" class="headerlink" title="OC代码转C/C++"></a>OC代码转C/C++</h4><p>怎样进行OC到C/C++代码的转化呢？其实Xcode已经向我们提供了命令行转换工具，只要打开终端，执行以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件</span><br></pre></td></tr></table></figure>
<p>其中：-sdk参数为指定编译代码运行的平台（不同平台代码不一样）。-arch为指定架构，手机为arm64。（模拟器(i386)、32bit(armv7)、64bit（arm64））</p>
<p>如果需要链接其他框架，使用-framework参数。比如-framework UIKit。</p>
<p>具体转换步骤：</p>
<ul>
<li><p>新建Xcode命令行项目</p>
</li>
<li><p>在main.m中创建一个最简单的NSObject对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开终端，定位到项目的 <code>main.m</code>。此步建议通过安装插件<code>Go2Shell</code>执行。</p>
</li>
<li><p>运行命令 <code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  main.m  -o cppmain.cpp</code></p>
</li>
<li><p>转换完成，通过<code>open ./</code>打开Finder找到cppmain.cpp文件</p>
</li>
</ul>
<h4 id="C-C-底层实现"><a href="#C-C-底层实现" class="headerlink" title="C/C++底层实现"></a>C/C++底层实现</h4><p>C/C++部分代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="built_in">NSObject</span> *obj = ((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSObject</span> *(*)	(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码可以看出，创建一个<code>NSObject</code>对象其实底层就是通过<code>objc_msgSend</code>发送消息。分配空间消息为<code>alloc</code>，初始化消息为<code>init</code>。但是只通过这些代码我们还看不出OC对象的底层实现。</p>
<p>进一步在cpp搜索文件搜索关键词<code>NSObject</code>，可以找到以下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很明显这是一个结构体。结构体里面就一个<em>Class</em>成员。此时我们跳转到<em>Class</em>的定义部分：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>这是一个结构体指针，指向<code>struct objc_class</code>。所以，一个OC对象在内存中是如何布局的，到这里应该比较清晰明了了。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvzpj6rmasj31kw0li44j.jpg" alt="屏幕快照 2018-10-07 下午3.48.38"></p>
<p>根据目前我们已知的部分，可以总结出：<code>NSObject</code>实例对象底层是通过结构体来实现的，每个结构体内部都有一个<code>isa</code>指针，指向创建它的类的内存地址。</p>
<p>现在回到开篇那道面试题：一个NSObject对象到底占据了多大的内存空间呢？我们知道，在64位操作系统环境下，一个指针占据8个字节的内存空间，正好一个<code>NSObject_IMPL</code>结构体里面有一个指针，这是不是就意味着一个NSObject对象占据8个字节的存储空间呢？我们不妨通过代码去进行验证一下。</p>
<p>目前计算所占空间大小主要有两种方案。首先导入所需函数的头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>调用的函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>class_getInstanceSize(&lt;<span class="meta">#Class  _Nullable __unsafe_unretained cls#&gt;);</span></span><br><span class="line"><span class="number">2.</span>malloc_size(<span class="keyword">const</span> <span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8 打印结果为8</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 获得obj指针所指向内存的大小 &gt;&gt; 16 打印结果为16</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)obj));</span><br></pre></td></tr></table></figure>
<p>函数说明：<code>class_getInstanceSize</code>需要我们传入具体的实例对象。属于运行时系统的API，动态计算实例对象的实例变量实际占用了多少内存空间。而<code>malloc_size</code>属于C语言API，要求我们传入一个指针，能够获取到系统实际分配了多少内存给对象。传入OC对象的时候需要<code>__bridge</code>进行桥接。</p>
<p><code>class_getInstanceSize</code>返回值结果为8，<code>malloc_size</code>返回值为16，为什么不一样呢？其实在上面的函数说明部分已经有解释了，下面我们通过<code>runtime</code>源码进行进一步分析。</p>
<h4 id="Runtime-amp-allocWithZone源码分析"><a href="#Runtime-amp-allocWithZone源码分析" class="headerlink" title="Runtime&amp;allocWithZone源码分析"></a>Runtime&amp;allocWithZone源码分析</h4><p>首先我们要知道的一点是，目前OC实现的源码已经是部分开源的。我们可以通过访问 <a href="n&lt;https://opensource.apple.com/tarballs/objc4/">opensource.apple.com</a>找到最新的（数字最大）的版本进行下载。</p>
<p>解压并打开我们下载的objc4文件，搜索到<code>class_getInstanceSize</code>的实现部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> class_getInstanceSize(Class cls)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 <code>alignedInstanceSize</code>函数内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line"><span class="keyword">uint32_t</span> alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释的说明文字部分可以看出，这个函数返回的是对象内部的实例变量实际所占用的内存空间大小（ivar代表成员变量，后面的章节会讲到）。现在对比<code>malloc_size</code>函数，我们可以探究一下<code>NSObject</code>调用<code>alloc</code>方法的底层实现：</p>
<ul>
<li>打开上述下载的源码文件<code>objc4</code>,搜索<code>allocWithZone</code>方法</li>
<li>找到函数<code>_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)</code>，在此方法的实现中查看<code>obj = class_createInstance(cls, 0)</code>函数，并跳转其实现代码部分。</li>
<li>在<code>class_createInstance</code>函数实现中查找<code>_class_createInstanceFromZone(cls, extraBytes, nil)</code>,并跳转其实现代码部分</li>
<li>在<code>_class_createInstanceFromZone</code>实现里查找<code>size_t size = cls-&gt;instanceSize(extraBytes)</code>,并跳转其实现部分。</li>
</ul>
<p>以下为<code>cls-&gt;instanceSize(extraBytes)</code>函数为OC对象分配内存空间的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> instanceSize(<span class="keyword">size_t</span> extraBytes) &#123;</span><br><span class="line">	<span class="keyword">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    	 <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果计算出来的size小于16，系统会把分配的内存空间置为16。换句话说，系统在为OC对象分配存储空间时，有一个硬性规定，那就是最小为16个字节大小。</p>
<p>通过以上分析总结出以下结论：</p>
<ul>
<li><strong>系统分配了16个字节给NSObject对象（通过malloc_size函数获得）。</strong></li>
<li><strong>但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）</strong></li>
</ul>
<h4 id="另一种角度"><a href="#另一种角度" class="headerlink" title="另一种角度"></a>另一种角度</h4><p>我们也通过Xcode提供的工具来窥探OC对象所占用内存。还是用上面的创建的<code>NSObject</code>对象的工程，在创建代码下一行代码处打一个断点。</p>
<ul>
<li><p>运行程序，在断点停止的时候点击小叹号查看对象的内存地址。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw0klqd6stj31de0bin54.jpg" alt="屏幕快照 2018-10-07 下午7.12.01"></p>
</li>
<li><p>控制台复制对象的内存地址。进入：Debug -&gt; Debug Workfllow -&gt; View Memory （Shift + Command + M）</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw0kmbwjclj31c80yohdt.jpg" alt="屏幕快照 2018-10-07 下午7.13.37"></p>
</li>
<li><p>在下图箭头所指向的输入框内粘贴对象地址，查看。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw0kqqd1vlj31c815u7fa.jpg" alt="屏幕快照 2018-10-07 下午7.14.34"></p>
</li>
</ul>
<p>上面这张图中，第一行蓝线和绿线标识的部分（16个字节）即为<code>NSObject</code>对象分配的内存地址。不难看出，对象实际上只使用了前8个字节的内存地址，剩余8个字节为空值。</p>
<p>这种方式类似于我们常用的<strong>LLDB指令</strong>，拿到对象的地址以后可以进行 <code>memory read</code>。打印结果与上图展示的一样，这里不做详细介绍。以下是常用的LLDB指令：</p>
<ul>
<li>print、p:打印</li>
<li>po:打印对象</li>
<li>memory read：读取内存。常用格式为<code>memory read/数量格式字节数 内存地址</code>。常用简写方式：<code>x/数量格式字节数 内存地址</code>。例如<code>x/3xw 0x10010</code>。这里说明下格式：x代表16进制，f是浮点，d是十进制。字节大小的表示为：<code>b:byte 1个字节。 h:half word 2个字节。w：word 4字节。g：giant word 8字节</code></li>
<li>修改内存中的值：pmemory  write  内存地址  数值</li>
</ul>
<h4 id="复杂对象的内存分配问题"><a href="#复杂对象的内存分配问题" class="headerlink" title="复杂对象的内存分配问题"></a>复杂对象的内存分配问题</h4><p>先来思考下面这段代码的输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Person */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Student */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd  %zd"</span>,</span><br><span class="line">              class_getInstanceSize([Person <span class="keyword">class</span>]),</span><br><span class="line">              class_getInstanceSize([Student <span class="keyword">class</span>])</span><br><span class="line">              );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw311rrcz6j30tc0fetb6.jpg" alt="1434508-dded6a79a629de09"></p>
<p>只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。<br> 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。<br>实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。</p>
<blockquote>
<p>编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。<br> 为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</p>
</blockquote>
<p>我们可以总结内存对齐为两个原则：</p>
<ul>
<li>前面的地址必须是后面的地址整数倍,不是就补齐。</li>
<li>整个Struct的地址必须是最大字节的整数倍。</li>
</ul>
<p>通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。</p>
<p>而对于student对象，我们知道sutdent对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。</p>
<h2 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h2><p>OC对象主要可以分为三种</p>
<ul>
<li>instance对象（实例对象）</li>
<li>class对象（类对象）</li>
<li>meta-class对象（元类对象）</li>
</ul>
<p>下面来一一介绍着三种对象。</p>
<h4 id="instance对象"><a href="#instance对象" class="headerlink" title="instance对象"></a>instance对象</h4><p>instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObjcet</span> *object1 = [[<span class="built_in">NSObjcet</span> alloc] init];</span><br><span class="line"><span class="built_in">NSObjcet</span> *object2 = [[<span class="built_in">NSObjcet</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p><code>object1</code>和<code>object2</code>都是NSObject的<code>instace</code>对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。<br>instance对象在内存中存储的信息包括:</p>
<ul>
<li><p>isa指针</p>
</li>
<li><p>其他成员变量（实际上是存放成员变量具体值）</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw31p8vtfqj30u307575h.jpg" alt="instance对象内存"></p>
</li>
</ul>
<p>但是，在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？</p>
<h4 id="class对象"><a href="#class对象" class="headerlink" title="class对象"></a>class对象</h4><p>我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass1 = [object1 <span class="keyword">class</span>];</span><br><span class="line">Class objectClass2 = [object2 <span class="keyword">class</span>];</span><br><span class="line">Class objectClass3 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime</span></span><br><span class="line">Class objectClass4 = object_getClass(object1);</span><br><span class="line">Class objectClass5 = object_getClass(object2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p %p %p %p"</span>, objectClass1, objectClass2, objectClass3, objectClass4, objectClass5);</span><br></pre></td></tr></table></figure>
<p>每一个类在内存中有且只有一个class对象。可以通过打印内存地址证明.</p>
<p>class对象在内存中存储的信息主要包括:</p>
<ol>
<li><p>isa指针</p>
</li>
<li><p>superclass指针</p>
</li>
<li><p>类的属性信息（@property），类的成员变量信息（ivar）</p>
</li>
<li><p>类的对象方法信息（instance method），类的协议信息（protocol）</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw321ygjayj308s0ejq3d.jpg" alt="class对象在内存中存储的信息图例"></p>
<p>成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。所以存储在class对象中。</p>
<p>那么，类方法放到哪里的呢？</p>
</li>
</ol>
<p>####meta-class对象 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runtime中传入类对象此时得到的就是元类对象</span></span><br><span class="line">Class objectMetaClass = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象</span></span><br><span class="line">Class cls = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] <span class="keyword">class</span>];</span><br><span class="line">Class objectClass3 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">class_isMetaClass(objectMetaClass) <span class="comment">// 判断该对象是否为元类对象</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p %p"</span>, objectMetaClass, objectClass3, cls); <span class="comment">// 后面两个地址相同，说明多次调用class得到的还是类对象</span></span><br></pre></td></tr></table></figure>
<p>每个类在内存中有且只有一个meta-class对象。<br>meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括:</p>
<ol>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的类方法的信息（class method）</li>
</ol>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw32658p78j309409vdfz.jpg" alt="元类meta-class对象在内存存储的信息图例"></p>
<p>meta-class对象和class对象的内存结构是一样的，所以<code>meta-class</code>中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。</p>
<h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><p>当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。</p>
<p>instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。</p>
<p>当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象</p>
<p>class的isa指向meta-class,当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw32dfwefhj30vt0cemye.jpg" alt="isa指针指向图例 "></p>
<p>当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[stu personMethod];</span><br><span class="line">[stu init];</span><br></pre></td></tr></table></figure>
<p>当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw32gjp18pj30z20cnq4k.jpg" alt="对象调用父类对象方法图例"></p>
<p>当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Student personClassMethod];</span><br><span class="line">[Student load];</span><br></pre></td></tr></table></figure>
<p>当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用.</p>
<p>最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw32ijebqdj30ch0d2t97.jpg" alt="经典的isa指向图"></p>
<p><strong>对isa、superclass总结</strong></p>
<ul>
<li><p>instance的isa指向class</p>
</li>
<li><p>class的isa指向meta-class</p>
</li>
<li><p>meta-class的isa指向基类的meta-class，基类的isa指向自己</p>
</li>
<li><p>class的superclass指向父类的class，如果没有父类，superclass指针为nil</p>
</li>
<li><p>meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class</p>
</li>
<li><p>instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类</p>
</li>
<li><p>class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类</p>
</li>
</ul>
<h2 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h2><p>###Class底层结构</p>
<p>我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];        </span><br><span class="line">Class objectMetaClass = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>
<p>点击Class来到内部，我们可以发现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>Class对象其实是一个指向objc_class结构体的指针。因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。</p>
<p>我们来到objc_class内部，可以看到这段在底层原理中经常出现的代码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<p>这部分代码相信在文章中很常见，但是<code>OBJC2_UNAVAILABLE;</code>说明这些代码已经不在使用了。那么目前objc_class的结构是什么样的呢？我们通过objc源码中去查找objc_class结构体的内容。</p>
<p>打开我们在<strong>Runtime&amp;allocWithZone源码分析</strong>章节中下载的<code>objc4</code>源码，搜索<code>objc_class</code>的实现部分，可以看到代码非常长，下面贴出最主要的部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这个结构体继承 objc_object 并且结构体内有一些函数，因为这是c++结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到objc_object内，截取部分代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现objc_object中有一个isa指针，那么objc_class继承objc_object，也就同样拥有一个isa指针。</p>
<p>那么我们之前了解到的，类中存储的类的成员变量信息，实例方法，属性名等这些信息在哪里呢。我们来到<code>class_rw_t</code>中，截取部分代码，我们发现<code>class_rw_t</code>中存储着方法列表，属性列表，协议列表等内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;	<span class="comment">//方法列表</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;<span class="comment">//属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;<span class="comment">//协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>class_rw_t</code>是通过<code>bits</code>调用<code>data</code>方法得来的，我们来到data方法内部实现。我们可以看到，data函数内部仅仅对bits进行<code>&amp;FAST_DATA_MASK</code>操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_rw_t</span>* data() &#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>而成员变量信息则是存储在class_ro_t内部中的，我们来到class_ro_t内查看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后总结通过一张图进行总结:</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw333fd2pzj30qm0chjv2.jpg" alt="struct objc_class的结构"></p>
<h3 id="实践验证"><a href="#实践验证" class="headerlink" title="实践验证"></a>实践验证</h3><p>我们可以自定义一个结构体，如果我们自己写的结构和objc_class真实结构是一样的，那么当我们强制转化的时候，就会一一对应的赋值。此时我们就可以拿到结构体内部的信息。</p>
<p>下列代码是我们仿照objc_class结构体，提取其中需要使用到的信息，自定义的一个结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPClassInfo_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPClassInfo_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">bucket_t</span> *_buckets;</span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entsize_list_tt</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsizeAndFlags;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> :</span> entsize_list_tt &#123;</span><br><span class="line">    <span class="keyword">method_t</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_list_t</span> :</span> entsize_list_tt &#123;</span><br><span class="line">    <span class="keyword">ivar_t</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> :</span> entsize_list_tt &#123;</span><br><span class="line">    <span class="keyword">property_t</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chained_property_list</span> &#123;</span></span><br><span class="line">    chained_property_list *next;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">    <span class="keyword">property_t</span> <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">protocol_ref_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> count;</span><br><span class="line">    <span class="keyword">protocol_ref_t</span> <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;  <span class="comment">// instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;  <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    <span class="keyword">method_list_t</span> * methods;    <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *properties;    <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">protocol_list_t</span> * protocols;  <span class="comment">// 协议列表</span></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class_rw_t</span>* data() &#123; <span class="comment">// 提供data()方法进行 &amp; FAST_DATA_MASK 操作</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OC对象 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sp_objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类对象 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sp_objc_class</span> :</span> sp_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;</span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class_rw_t</span>* data() &#123;</span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">sp_objc_class* <span class="title">metaClass</span><span class="params">()</span> </span>&#123; <span class="comment">// 提供metaClass函数，获取元类对象</span></span><br><span class="line"><span class="comment">// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</span></span><br><span class="line">        <span class="keyword">return</span> (sp_objc_class *)((<span class="keyword">long</span> <span class="keyword">long</span>)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* spClassInfo_h */</span></span></span><br></pre></td></tr></table></figure>
<p>接下来我们将自己定义的类强制转化为我们自定义的精简的class结构体类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SPClassInfo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person */</span></span><br><span class="line">@interface Person : NSObject &lt;NSCopying&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @<span class="keyword">public</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, assign) <span class="keyword">int</span> height;</span><br><span class="line">- (<span class="keyword">void</span>)personMethod;</span><br><span class="line">+ (<span class="keyword">void</span>)personClassMethod;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (<span class="keyword">void</span>)personMethod &#123;&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)personClassMethod &#123;&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Student */</span></span><br><span class="line">@interface Student : Person &lt;NSCoding&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @<span class="keyword">public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) <span class="keyword">int</span> score;</span><br><span class="line">- (<span class="keyword">void</span>)studentMethod;</span><br><span class="line">+ (<span class="keyword">void</span>)studentClassMethod;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">- (<span class="keyword">void</span>)studentMethod &#123;&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)studentClassMethod &#123;&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSObject *object = [[NSObject alloc] init];</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        sp_objc_class *objectClass = (__bridge sp_objc_class *)[object class];</span><br><span class="line">        sp_objc_class *personClass = (__bridge sp_objc_class *)[person class];</span><br><span class="line">        sp_objc_class *studentClass = (__bridge sp_objc_class *)[student class];</span><br><span class="line">        </span><br><span class="line">        sp_objc_class *objectMetaClass = objectClass-&gt;metaClass();</span><br><span class="line">        sp_objc_class *personMetaClass = personClass-&gt;metaClass();</span><br><span class="line">        sp_objc_class *studentMetaClass = studentClass-&gt;metaClass();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class_rw_t</span> *objectClassData = objectClass-&gt;data();</span><br><span class="line">        <span class="keyword">class_rw_t</span> *personClassData = personClass-&gt;data();</span><br><span class="line">        <span class="keyword">class_rw_t</span> *studentClassData = studentClass-&gt;data();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class_rw_t</span> *objectMetaClassData = objectMetaClass-&gt;data();</span><br><span class="line">        <span class="keyword">class_rw_t</span> *personMetaClassData = personMetaClass-&gt;data();</span><br><span class="line">        <span class="keyword">class_rw_t</span> *studentMetaClassData = studentMetaClass-&gt;data();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0x00007ffffffffff8</span></span><br><span class="line">        NSLog(@<span class="string">"%p %p %p %p %p %p"</span>,  objectClassData, personClassData, studentClassData,</span><br><span class="line">              objectMetaClassData, personMetaClassData, studentMetaClassData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过打断点，我们可以看到class内部信息。</p>
<h4 id="instance对象-1"><a href="#instance对象-1" class="headerlink" title="instance对象"></a>instance对象</h4><p>首先我们来看instance对象，我们通过上一篇文章知道，instance对象中存储着isa指针和其他成员变量，并且instance对象的isa指针是指向其<strong>类对象</strong>地址的。我们首先分析上述代码中我们创建的object，person，student三个instance对象与其相对应的类对象objectClass，personClass，studentClass。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw33k0ci8vj30q8090gp8.jpg" alt="instance对象分析"></p>
<p>从上图中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。</p>
<h4 id="class对象-1"><a href="#class对象-1" class="headerlink" title="class对象"></a>class对象</h4><p>接着我们来看class对象，同样通过上一篇文章，我们明确class对象中存储着isa指针，superclass指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对object源码的分析，我们知道这些信息存储在class对象的class_rw_t中，我们通过强制转化来窥探其中的内容。如下图</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw33l7dkb3j30ck0jgady.jpg" alt="personClassData内结构"></p>
<p>上图中我们通过模拟对person类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。即上图中的personClassData。其中我们发现成员变量信息，对象方法，属性等信息只显示first第一个，如果想要拿到更多的需要通过代码将指针后移获取。而上图中的instaceSize = 16也同person对象中isa指针8个字节+_age4个字节+_height4个字节相对应起来。这里不在展开对objectClassData及studentClassData进行分析，基本内容同personClassData相同。</p>
<h4 id="meta-class对象"><a href="#meta-class对象" class="headerlink" title="meta-class对象"></a>meta-class对象</h4><p>最后我们来看meta-class元类对象，上文提到meta-class中存储着isa指针，superclass指针，以及类的类方法信息。同时我们知道meta-class元类对象与class类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的isa指针指向基类的元类对象，基类的元类对象的isa指针指向自己。元类对象的superclass指针指向其父类的元类对象，基类的元类对象的superclass指针指向其类对象。</p>
<p>与class对象相同，我们同样通过模拟对person元类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw33n72se1j30ep0d0tbc.jpg" alt="personMetaClassData内结构"></p>
<p>首先我们可以看到结构同personClassData相同，并且成员变量及属性列表等信息为空，而methods中存储着类方法personClassMethod。</p>
<p>接着来验证isa及superclass指针的指向是否同上图序号标注一样。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw33o1y5fsj30vj06h41r.jpg" alt="meta-class的isa指针指向"></p>
<p>上图中通过地址证明meta-class的isa指向基类的meta-class，基类的isa指针也指向自己。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw33p9vj7pj30tw06l0wh.jpg" alt="meta-class的superclass指针指向"></p>
<p>上图中通过地址证明meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class类。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/iOS 9、10、11新特性/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/iOS 9、10、11新特性/" itemprop="url">iOS 9新特性及相关变化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-iOS-9新特性及相关变化"><a href="#1-iOS-9新特性及相关变化" class="headerlink" title="1.iOS 9新特性及相关变化"></a>1.iOS 9新特性及相关变化</h2><h3 id="新添加"><a href="#新添加" class="headerlink" title="新添加"></a>新添加</h3><h4 id="1-1-Contacts、ContactsUI"><a href="#1-1-Contacts、ContactsUI" class="headerlink" title="1.1 Contacts、ContactsUI"></a>1.1 Contacts、ContactsUI</h4><ul>
<li><p>iOS9之前：</p>
<p>AddressBookUI.framework：提供了联系人列表界面、联系人详情界面、添加联系人界面等</p>
<p>一般用于选择联系人</p>
<p>AddressBook.framework：纯C语言的API,仅仅是获得联系人数据<br>没有提供UI界面展示,需要自己搭建联系人展示界面</p>
</li>
<li><p>iOS9之后：</p>
<p>Contacts.framework和ContactsUI.framework这2个新的面向对象的库取代了之前的Address Book与Address Book UI frameworks来对通讯录进行相关操作。</p>
</li>
</ul>
<h4 id="1-2-CoreSpotlight"><a href="#1-2-CoreSpotlight" class="headerlink" title="1.2 CoreSpotlight"></a>1.2 CoreSpotlight</h4><p> 在iOS9之前，用户可以通过Spotlight中输入关键字来查找App。在iOS9中Apple随之发布了一套全新的iOS9 Search APIs之后，开发者不但可以自由的将App的部分内容建立索引，还能对Spotlight上的搜索结果以及点击不同的结果显示的内容进行设置。</p>
<h4 id="1-3-GameplayKit"><a href="#1-3-GameplayKit" class="headerlink" title="1.3 GameplayKit"></a>1.3 GameplayKit</h4><p>游戏开发相关：GamePlayKit是一个帮助新手开发者们在OS X和iOS平台创作游戏的基础工具和技术框架，可提供游戏资源、模块、玩法设计以及系统规则方面的内容。</p>
<h4 id="1-4-MetalKit"><a href="#1-4-MetalKit" class="headerlink" title="1.4 MetalKit"></a>1.4 MetalKit</h4><p>Apple为游戏开发者推出了新的平台技术 Metal，该技术能够为 3D 图像提高 10 倍的渲染性能，并支持大家熟悉的游戏引擎及公司。</p>
<h4 id="1-5-MetalPerformanceShaders"><a href="#1-5-MetalPerformanceShaders" class="headerlink" title="1.5 MetalPerformanceShaders"></a>1.5 MetalPerformanceShaders</h4><p>MetalPerformanceShaders是apple推出的一套通过metal来在ios上实现深度学习的工具。</p>
<h4 id="1-6-ModelIO"><a href="#1-6-ModelIO" class="headerlink" title="1.6 ModelIO"></a>1.6 ModelIO</h4><p>Model I/O是用处理3D资源和数据的框架，我们可以通过Model I/O快速地加载和导出3D资源文件。它集成在Xcode里面并且和可以非常容易地与GameKit API配合。</p>
<h4 id="1-7-ReplayKit"><a href="#1-7-ReplayKit" class="headerlink" title="1.7 ReplayKit"></a>1.7 ReplayKit</h4><p>提供录屏功能的一套全新框架，它可以让玩家更便捷地记录游戏或者应用的画面，录制自己的声音。ReplayKit为用户或者玩家提供了一个全功能的交互界面，用户可用它来编辑或制作自己的视频剪辑。ReplayKit不需要太大电量损耗和性能损耗就可以产出高清的视频记录。</p>
<p>关于 <a href="https://developer.apple.com/documentation/replaykit" target="_blank" rel="noopener">ReplayKit</a></p>
<h4 id="1-8-WatchConnectivity"><a href="#1-8-WatchConnectivity" class="headerlink" title="1.8 WatchConnectivity"></a>1.8 WatchConnectivity</h4><p>WatchConnectivity.framework提供iPhone和与之配对的Apple Watch之间进行双向的文件、数据传输。这套框架能够让配对的两个设备上同时运行的App进行即时通信，也可以进行后台通信。</p>
<h4 id="1-9-关于UIKit"><a href="#1-9-关于UIKit" class="headerlink" title="1.9 关于UIKit"></a>1.9 关于UIKit</h4><h5 id="1-9-1-新添加"><a href="#1-9-1-新添加" class="headerlink" title="1.9.1 新添加"></a>1.9.1 新添加</h5><blockquote>
<p>UIApplicationShortcutItem  </p>
<p>3DTouch开发相关的类，他是一个数组类型，数组中的每一个元素表示一个入口标签。可在plist的文件中配置每一个item相关的信息，也可以在代码里配置，但是在代码里配置的话，3DTouch弹出的标签生效是在一次启动之后。</p>
<p>NSDataAsset  </p>
<p>访问用特定格式存储在asset catalog里面的一个对象，用于操作assets.xcassets文件的。</p>
<p>NSLayoutAnchor  </p>
<p>apple的解释为：</p>
<blockquote>
<p>The NSLayoutAnchor class is a factory class for creating NSLayoutConstraint objects using a fluent API. Use these constraints to programatically define your layout using Auto Layout</p>
<p>NSLayoutAnchor是一个专门用于创建NSLayoutConstraint的工厂类，其API简明，流畅。利用所创建的约束，以代码的形式搭建使用自动布局技术的界面。</p>
</blockquote>
<p>多数情况下，我们设置约束时是操作NSLayoutAnchor的子类。</p>
<ul>
<li><p>NSLayoutYAxisAnchor: Y轴约束。</p>
</li>
<li><p>NSLayoutXAxisAnchor：X轴约束。</p>
</li>
<li><p>NSLayoutDimension：界面约束，如宽和高。</p>
<p>代码添加约束在iOS9之前相当繁琐，也许是apple收到第三方框架的鼓舞，在iOS9中加入了NSLayoutAnchor来简化代码自动布局的方式，以下示例是添加相同的约束使用NSLayoutConstraint和NSLayoutAnchor的对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;   // Creating constraints using NSLayoutConstraint</span><br><span class="line">&gt;   [NSLayoutConstraint</span><br><span class="line">&gt;    constraintWithItem:subview</span><br><span class="line">&gt;    attribute:NSLayoutAttributeLeading</span><br><span class="line">&gt;    relatedBy:NSLayoutRelationEqual</span><br><span class="line">&gt;    toItem:self.view</span><br><span class="line">&gt;    attribute:NSLayoutAttributeLeadingMargin</span><br><span class="line">&gt;    multiplier:1.0</span><br><span class="line">&gt;    constant:0.0].active = YES;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;   [NSLayoutConstraint</span><br><span class="line">&gt;    constraintWithItem:subview</span><br><span class="line">&gt;    attribute:NSLayoutAttributeTrailing</span><br><span class="line">&gt;    relatedBy:NSLayoutRelationEqual</span><br><span class="line">&gt;    toItem:self.view</span><br><span class="line">&gt;    attribute:NSLayoutAttributeTrailingMargin</span><br><span class="line">&gt;    multiplier:1.0</span><br><span class="line">&gt;    constant:0.0].active = YES;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;   // Creating the same constraints using Layout Anchors</span><br><span class="line">&gt;   UILayoutGuide *margin = self.view.layoutMarginsGuide;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;   [subview.leadingAnchor constraintEqualToAnchor:margin.leadingAnchor].active = YES;</span><br><span class="line">&gt;   [subview.trailingAnchor constraintEqualToAnchor:margin.trailingAnchor].active = YES;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p>  ​</p>
<p>UIBarButtonItemGroup  </p>
<p>iPad键盘快捷栏上的一组按钮的集合</p>
<p>UIFieldBehavior  </p>
<p>物理效果相关的类，iOS9中包含以下类型的behaviours：</p>
<ul>
<li>Linear Gravity</li>
<li>Radial Gravity</li>
<li>Noise</li>
<li>Custom</li>
</ul>
<p><a href="https://developer.apple.com/documentation/uikit/uifieldbehavior?language=objc" target="_blank" rel="noopener">UIFieldBehavior </a></p>
<p>UILayoutGuide </p>
<p>UILayoutGuide是 <strong>iOS 9</strong> 中增加的帮助开发者在使用auto layout布局时的一个虚拟占位对象。它更轻量、更快速、更高效。UILayoutGuide并没有真正的创建一个View，只是创建了一个矩形空间，只在进 autolayout时参与进来计算。</p>
<p>参考 <a href="https://www.jianshu.com/p/b5c3e0482f29" target="_blank" rel="noopener">是时候了解一下UILayoutGuide了</a></p>
<p>UIRegion  </p>
<blockquote>
<p>When creating animations, you use regions to define the effective area of a field behavior such as a magnetic or gravitational force. Most regions are rectangular or elliptical in shape, but you can use the methods of this class to create more complex shapes by adding, subtracting, and intersecting other regions.</p>
<p>在创建磁力或者引力的效果动画的时候，我们使用regions去定义它的有效作用范围。但是，大多数的regions是椭圆或者矩形形状，我们可以使用UIRegion去自定义更为复杂的形状，比如增加或者裁剪其中的部分区域。</p>
</blockquote>
<p>UIStackView  </p>
<p>UIStackView类可以帮我们布局<strong>UI</strong>控件，而我们不需要设置任何约束或设置很少的约束就可以，其他都由UIStackView帮我们自动完成了</p>
</blockquote>
<h5 id="1-9-2-常用UI改动"><a href="#1-9-2-常用UI改动" class="headerlink" title="1.9.2 常用UI改动"></a>1.9.2 常用UI改动</h5><blockquote>
<p>UITabBarItem.h : 删除了 [UITabBarItem setTitlePositionAdjustment:]<br>UITableView.h : 新增 UITableView.cellLayoutMarginsFollowReadableWidth<br>UITouch : 新增 UITouch.force 、 UITouch.maximumPossibleForce、UIForceTouchCapability、UIForceTouchCapabilityAvailable、UIForceTouchCapabilityUnavailable、UIForceTouchCapabilityUnknown<br>UIView : 删除 -[UIView setTranslatesAutoresizingMaskIntoConstraints:]<br>UIViewController 新增部分方法<br>UIEvent.h : 新添加[UIEvent coalescedTouchesForTouch:]、 [UIEvent predictedTouchesForTouch:]<br>UICollectionViewLayout ：新添加部分方法<br>UICollectionView ：新添加部分方法<br>NSAttributedString ：新添加部分分类  </p>
</blockquote>
<h5 id="1-9-3-Foundation"><a href="#1-9-3-Foundation" class="headerlink" title="1.9.3 Foundation"></a>1.9.3 Foundation</h5><blockquote>
<p>新添加 NSPersonNameComponents.h NSPersonNameComponentsFormatter.hNString : 添加了部分方法<br>NSURL : 添加了部分方法<br>NSURLSession s  </p>
</blockquote>
<h4 id="1-10-新特性"><a href="#1-10-新特性" class="headerlink" title="1.10 新特性"></a>1.10 新特性</h4><h5 id="1-10-1-URL-Scheme-适配-引入白名单概念"><a href="#1-10-1-URL-Scheme-适配-引入白名单概念" class="headerlink" title="1.10.1 URL Scheme 适配_引入白名单概念"></a>1.10.1 URL Scheme 适配_引入白名单概念</h5><p>在iOS9中，若要通过URL Scheme访问其他APP，则需要事先将该URL加入程序的白名单中。</p>
<p>这个URL Scheme机制的改变主要影响了两个api：canOpenURL和openURL。在iOS9以前，如果要判断系统中有没有APP能够处理相应的URL，直接调用canOpenURL就可以了，openURL同理。而在iOS9之后，若要访问某个URL，则必须在程序的info.plist中把访问的URL提前设置好，将其加入白名单中，才能够顺利使用canOpenURL和openURL，否则，系统会拒绝访问，直接返回NO。</p>
<h5 id="1-10-2-网络适配-ATS：改用更安全的HTTPS"><a href="#1-10-2-网络适配-ATS：改用更安全的HTTPS" class="headerlink" title="1.10.2 网络适配_ATS：改用更安全的HTTPS"></a>1.10.2 网络适配_ATS：改用更安全的HTTPS</h5><p>iOS9中发送一个http请求会报以下错误</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>ATS全称为App Transport Security。为了提高iOS设备与服务器交互的安全性，apple的ATS会阻止未注册的网络请求，所以服务端需要适配https。当然APP当中可能存在一些第三方库有http请求，这时候需要将这些请求加入白名单。</p>
<h5 id="1-10-3-Bitcode"><a href="#1-10-3-Bitcode" class="headerlink" title="1.10.3 Bitcode"></a>1.10.3 Bitcode</h5><p>bitcode 是被编译程序的一种中间形式的代码。包含 bitcode 配置的程序将会在 App Store 上被编译和链接。 bitcode 允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到 App Store 上。</p>
<p>使用bitcode要注意以下几点</p>
<ul>
<li>Xcode 7默认开启 Bitcode ，如果应用开启 Bitcode，那么其集成的其他第三方库也需要是 Bitcode 编译的包才能真正进行 Bitcode 编译</li>
<li>开启 Bitcode 编译后，编译产生的  .app 体积会变大(中间代码，不是用户下载的包)，且  .dSYM文件不能用来崩溃日志的符号化(用户下载的包是 Apple 服务重新编译产生的，有产生新的符号文件)。</li>
<li>通过 Archive 方式上传 AppStore 的包，可以在Xcode的Organizer工具中下载对应安装包的新的符号文件</li>
</ul>
<h2 id="2-iOS-10新特性及相关变化"><a href="#2-iOS-10新特性及相关变化" class="headerlink" title="2.iOS 10新特性及相关变化"></a>2.iOS 10新特性及相关变化</h2><h3 id="新添加-1"><a href="#新添加-1" class="headerlink" title="新添加"></a>新添加</h3><h4 id="2-1-CallKit"><a href="#2-1-CallKit" class="headerlink" title="2.1 CallKit"></a>2.1 CallKit</h4><ul>
<li>不仅让VoIP应用具有系统电话一样的功能，还能帮助系统实现来电识别等功能；但本身并不具备voip功能</li>
<li>后台或锁屏时直接通过系统电话界面接管VoIP语音来电，并更新回调电话操作到app</li>
</ul>
<p><a href="https://www.jianshu.com/p/35b59089134e" target="_blank" rel="noopener">关于CallKit</a></p>
<h4 id="2-2-Intents-amp-IntentsUI"><a href="#2-2-Intents-amp-IntentsUI" class="headerlink" title="2.2 Intents &amp; IntentsUI"></a>2.2 Intents &amp; IntentsUI</h4><p>之所以把这两个框架放到一起，是因为他们和<a href="https://developer.apple.com/documentation/sirikit" target="_blank" rel="noopener">SiriKit</a>有很大的相关性。</p>
<p>SiriKit 为我们提供一全套从语音识别到代码处理，最后向用户展示结果的流程。Apple 加入了一套全新的框架 <strong>Intents.framework</strong> 来表示 Siri 获取并解析的结果。你的应用需要提供一些关键字表明可以接受相关输入，而 Siri 扩展只需要监听系统识别的用户<strong>意图 (intent)</strong>，作出合适的响应，修改以及实际操作，最后通过 <strong>IntentsUI.framework</strong> 提供反馈。整个过程非常清晰明了，但是这也意味着开发者所能拥有的自由度有限。</p>
<h4 id="2-3-MetalKit"><a href="#2-3-MetalKit" class="headerlink" title="2.3 MetalKit"></a>2.3 MetalKit</h4><ul>
<li><p>一个为计算机GPU编程的接口</p>
</li>
<li><p>提供最底层的GPU访问接入,因此它将减少其他框架中由于在CPU和GPU之间传递数据而经常引起的性能瓶颈.</p>
<p>  提供相比OpenGL高达10倍的绘制调用.然而,Metal并不能像OpenGL一样跨平台,所以它并不能替代OpenGL.</p>
</li>
</ul>
<p><a href="https://developer.apple.com/documentation/metalkit" target="_blank" rel="noopener">关于MetalKit</a></p>
<h4 id="2-4-Messages"><a href="#2-4-Messages" class="headerlink" title="2.4 Messages"></a>2.4 Messages</h4><p>一套用来开发Message App的框架，分为独立应用和扩展两种。具体使用方法可参考文章</p>
<p><a href="https://my.oschina.net/u/2340880/blog/749331" target="_blank" rel="noopener">iOS10中Messages独立应用与扩展插件详析</a></p>
<h4 id="2-5-Speech"><a href="#2-5-Speech" class="headerlink" title="2.5 Speech"></a>2.5 Speech</h4><p>语音识别框架，可用来实现语音与文本的相互转化。具有以下特点：</p>
<ul>
<li>可以实现连续的语音识别</li>
<li>可以对语音文件或者语音流进行识别</li>
<li>最佳化自由格式的听写(可理解为多语言支持)和搜索式的字符串</li>
</ul>
<p><a href="https://developer.apple.com/documentation/speech?language=objc" target="_blank" rel="noopener">Speech官方文档</a></p>
<h4 id="2-6-UserNotifications"><a href="#2-6-UserNotifications" class="headerlink" title="2.6 UserNotifications"></a>2.6 UserNotifications</h4><p>iOS10中Apple对以往Notification的API进行了一次大的重构，现在可以使用独立的 UserNotifications.framework 来集中管理和使用 iOS 系统中通知的功能，这其中整合了本地通知个远程通知，并增加了一系列的功能：</p>
<ul>
<li>撤回单条通知</li>
<li>更新已展示通知</li>
<li>中途修改通知内容</li>
<li>在通知中展示图片视频</li>
<li>自定义通知 UI </li>
</ul>
<p>详情参考喵神文章 <a href="https://onevcat.com/2016/08/notification/" target="_blank" rel="noopener">活久见的重构 - iOS 10 UserNotifications 框架解析</a></p>
<h4 id="2-7-UserNotificationsUI"><a href="#2-7-UserNotificationsUI" class="headerlink" title="2.7 UserNotificationsUI"></a>2.7 UserNotificationsUI</h4><blockquote>
<p>Customize the interface used to display local and remote notifications.</p>
<p>自定义本地或远程通知UI展示界面</p>
</blockquote>
<h4 id="2-8-增加相关系统权限开启，需要info-plist中配置相应的key"><a href="#2-8-增加相关系统权限开启，需要info-plist中配置相应的key" class="headerlink" title="2.8 增加相关系统权限开启，需要info.plist中配置相应的key"></a>2.8 增加相关系统权限开启，需要info.plist中配置相应的key</h4><p>在iOS10系统中，如果不做额外设置，直接调用系统相册相机等权限，会出现以下崩溃</p>
<blockquote>
<p>This app has crashed because it attempted to access<br>privacy-sensitive data without a usage description. The app’s<br>Info.plist must contain an NSPhotoLibraryUsageDescription key with a<br>string value explaining to the user how the app uses this data.</p>
</blockquote>
<p>需要在Plist文件中添加相关权限描述，不作赘述。</p>
<h4 id="2-9-UIKit相关变化"><a href="#2-9-UIKit相关变化" class="headerlink" title="2.9 UIKit相关变化"></a>2.9 UIKit相关变化</h4><h5 id="新添加的UI"><a href="#新添加的UI" class="headerlink" title="新添加的UI"></a>新添加的UI</h5><ul>
<li><p>UIAccessibilityCustomRotor</p>
<p>一种上下文相关功能，可帮助Voice Over用户找到相关元素的下一个实例，您可以使用此类的实例来查找文章中的下一个链接或文档中的下一个拼写错误的单词</p>
</li>
<li><p>UICloudSharingController</p>
<p>iClould相关，用于增加和删除CloudKit共享记录中的成员</p>
</li>
<li><p>UIContentSizeCategory</p>
<p>官方文档介绍为“Constants indicating the preferred size of your content”，相关资料太少，没怎么弄明白。估计和文本字体设置有关。</p>
</li>
<li><p>UIContentSizeCategoryAdjusting</p>
<p>可以使控件轻松实现对内容类别更改的自动调整的方法组合。适用于UILabel、UITextField、UITextView</p>
</li>
<li><p>UIFeedbackGenerator</p>
<p>当我们使用iPhone 7以上的设备滚动一个UIPickerView的时候，系统会给我们一个震动反馈用来增强用户体验。UIFeedbackGenerator是所有反馈产生器的抽象类。不要自己创建该类的实例或者子类，应该使用已经提供的子类：</p>
<ul>
<li><a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackgenerator?language=objc" target="_blank" rel="noopener"><code>UIImpactFeedbackGenerator</code></a> .使用碰撞反馈发生器来表明发生了碰撞。举个例子，当用户界面上的一个对象碰到什么东西、或者卡到某个地方的时候，触发碰撞反馈发生器。</li>
<li><a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator?language=objc" target="_blank" rel="noopener"><code>UISelectionFeedbackGenerator</code></a>. 使用选择反馈发生器来表明选择状态发生了改变。</li>
<li><a href="https://developer.apple.com/reference/uikit/uinotificationfeedbackgenerator?language=objc" target="_blank" rel="noopener"><code>UINotificationFeedbackGenerator</code></a>. 使用通知反馈发生器来表明成功，失败，警告。</li>
</ul>
</li>
<li><p>UIFocusGuide</p>
<p>UILayoutGuide的一个子类,表示一个不可见的可聚焦区域，可将焦点移动重定向到其他视图.</p>
</li>
<li><p>UIGraphicsRenderer</p>
<p>在之前，我们一般是创建一个 image 上下文，然后做一些自定义的绘图操作，接着获取上下文中的图像内容，然后结束这个上下文，这样才能获取到图片。Apple 新增了类 UIGraphicsRenderer，它是 block-based、full-color-managed，并且是可以拓展的新的图片绘制类。使用方法更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull context) &#123;</span><br><span class="line">    [[UIColor darkGrayColor] setStroke];</span><br><span class="line">    [context strokeRect:renderer.format.bounds];</span><br><span class="line">    [[UIColor colorWithRed:158/255.0 green:215/255.0 blue:245/255.0 alpha:1] setFill];</span><br><span class="line">    [context fillRect:CGRectMake(1, 1, 140, 140)];</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIPreviewInteraction</p>
<p>注册一个视图提供自定义用户体以验响应3DTouch交互的类。常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithView:(UIView *)view;	//注册视图的初始化方法</span><br><span class="line">- (CGPoint)locationInCoordinateSpace:(id&lt;UICoordinateSpace&gt;)coordinateSpace;	//返回用户当前按压屏幕的坐标</span><br><span class="line">- (void)cancelInteraction;	//停止交互</span><br></pre></td></tr></table></figure>
</li>
<li><p>UITextInteraction</p>
<p>枚举类型，用来说明用户期望与URL或文本附件进行交互的类型的常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef enum UITextItemInteraction : NSInteger &#123;</span><br><span class="line">    UITextItemInteractionInvokeDefaultAction,</span><br><span class="line">    UITextItemInteractionPresentActions,</span><br><span class="line">    UITextItemInteractionPreview</span><br><span class="line">&#125; UITextItemInteraction;</span><br></pre></td></tr></table></figure>
</li>
<li><p>​</p>
</li>
<li><p>UIViewPropertyAnimator</p>
<p>UIViewPropertyAnimator 可以称为属性动画器，是iOS10中新增的一个执行View动画的类，它主要具有一下的特点：</p>
<ul>
<li>可中断性</li>
<li>可擦除性</li>
<li>可翻转性</li>
<li>丰富的时间动画控制功能</li>
</ul>
<p>UIViewAnimating 实现自定义动画对象的接口类</p>
<p>UITimingCurveProvider 协议重新封装了时间函数，提供了做动画所需要的时间信息</p>
<p>UISpringTimingParameters 弹簧动画的时间信息</p>
</li>
</ul>
<h4 id="2-10-Foundation相关变化"><a href="#2-10-Foundation相关变化" class="headerlink" title="2.10 Foundation相关变化"></a>2.10 Foundation相关变化</h4><h5 id="新添加的API"><a href="#新添加的API" class="headerlink" title="新添加的API"></a>新添加的API</h5><ul>
<li><p>NSDateInterval</p>
<p>表示特定开始日期和结束日期之间的时间范围的对象</p>
</li>
<li><p>NSISO8601DateFormatter</p>
<p>一种Formatter，用以转换日期和他们的IOS 8601标准字符串</p>
</li>
<li><p>NSMeasurement</p>
<blockquote>
<p>A numeric quantity labeled with a unit of measure, with support for unit conversion and unit-aware calculations</p>
</blockquote>
<p>大概意思是：用度量单位标记的数字数量，支持单位换算和单位感知计算。物理计算相关的类。</p>
</li>
<li><p>NSMeasurementFormatter</p>
<p>一种Formatter，提供单位和度量的本地化表示。</p>
</li>
<li><p>NSUnit</p>
<p>代表度量单位的抽象类。</p>
</li>
</ul>
<h2 id="3-iOS-11新特性及相关变化"><a href="#3-iOS-11新特性及相关变化" class="headerlink" title="3. iOS 11新特性及相关变化"></a>3. iOS 11新特性及相关变化</h2><h3 id="新添加的库"><a href="#新添加的库" class="headerlink" title="新添加的库"></a>新添加的库</h3><h4 id="3-1-Core-ML"><a href="#3-1-Core-ML" class="headerlink" title="3.1 Core ML"></a>3.1 Core ML</h4><p>iOS的机器学习框架，也就是当今很火的AI的核心部分，通过将机器模型转为Core ML 可以理解的形式。</p>
<h4 id="3-2-ARKit"><a href="#3-2-ARKit" class="headerlink" title="3.2 ARKit"></a>3.2 ARKit</h4><p>iOS设备虚拟现实必备技能。</p>
<h4 id="3-3-Core-NFC"><a href="#3-3-Core-NFC" class="headerlink" title="3.3 Core NFC"></a>3.3 Core NFC</h4><p>iOS11中，苹果开放了NFC接口，什么是NFC，自行Google, 前段时间iPhone可以刷公交卡就是借助此技能。</p>
<h3 id="主要变化"><a href="#主要变化" class="headerlink" title="主要变化"></a>主要变化</h3><h3 id="3-4-UIViewController"><a href="#3-4-UIViewController" class="headerlink" title="3.4 UIViewController"></a>3.4 UIViewController</h3><p>topLayoutGuide, bottomLayoutGuide<br>这2个属性被标记为过期了，但是在Storyboard里设置约束的时候，还是会出现这2个属性</p>
<p>automaticallyAdjustsScrollViewInsets<br>这个属性也被标记过期了，可以使用UIScrollView的contentInsetAdjustmentBehavior替代</p>
<h3 id="3-5-UIScrollView"><a href="#3-5-UIScrollView" class="headerlink" title="3.5 UIScrollView"></a>3.5 UIScrollView</h3><p>新增contentInsetAdjustmentBehavior属性<br>替代之前UIViewController的automaticallyAdjustsScrollViewInsets，作用类似，会根据某些情况自动调整scrollview的contentInset（实际改变的是adjustedContentInset属性，contentInset属性不会变）</p>
<p>新增safeAreaInsets: UIEdgeInsets属性<br>只读属性，为了配合contentInsetAdjustmentBehavior使用</p>
<p>新增adjustedContentInset: UIEdgeInsets属性<br>只读属性，这个属性会根据safeAreaInsets的变化而变化<br>UIScrollViewDelegate</p>
<p>新增scrollViewDidChangeAdjustedContentInset，当adjustedContentInset变化时会调用<br>UIScrollView的这几个Inset的改变需要引起注意，他改变了原来的contentInset的逻辑（比如现在contentInset不会受UINavigationBar的isTranslucent影响了），可能会对现有的项目中的页面展示有影响，在项目适配iOS11时需要留意下。</p>
<h3 id="3-6-UINavigationBar"><a href="#3-6-UINavigationBar" class="headerlink" title="3.6 UINavigationBar"></a>3.6 UINavigationBar</h3><p>新增prefersLargeTitles: Bool属性<br>大标题，默认为false，当设置为true时，navigation bar会显示大标题，向上滑动页面，navigation bar 会变小直到显示成跟之前一样，同时title位置会发生变化<br>navigationController?.navigationBar.prefersLargeTitles = true</p>
<p>滚动的过程中，通过打印navigation bar 的frame发现，navigation bar 的高度会跟着变化<br>如果navigation bar是透明的，scrollview的safeAreaInsets属性也会跟着变化<br>大概关系是：<br>safeAreaInsets.top = navigationBar.frame.height+statusBar.height</p>
<h3 id="3-7-UINavigationItem"><a href="#3-7-UINavigationItem" class="headerlink" title="3.7 UINavigationItem"></a>3.7 UINavigationItem</h3><p>新增largeTitleDisplayMode属性<br>这个属性配合navigation bar的大标题使用的。<br>当navigation bar启用prefersLargeTitles后，这个属性才会生效，可以控制某个单独的ViewController中的large title显示模式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UINavigationItemLargeTitleDisplayMode</span>) &#123;</span><br><span class="line">    <span class="comment">/// Automatically use the large out-of-line title based on the state of the previous item in the navigation bar. An item with largeTitleDisplayMode=Automatic will show or hide the large title based on the request of the previous navigation item. If the first item pushed is set to Automatic, then it will show the large title if the navigation bar has prefersLargeTitles=YES.</span></span><br><span class="line">    <span class="built_in">UINavigationItemLargeTitleDisplayModeAutomatic</span>,</span><br><span class="line">    <span class="comment">/// Always use a larger title when this item is top most.</span></span><br><span class="line">    <span class="built_in">UINavigationItemLargeTitleDisplayModeAlways</span>,</span><br><span class="line">    <span class="comment">/// Never use a larger title when this item is top most.</span></span><br><span class="line">    <span class="built_in">UINavigationItemLargeTitleDisplayModeNever</span>,</span><br><span class="line">&#125; <span class="built_in">NS_SWIFT_NAME</span>(<span class="built_in">UINavigationItem</span>.LargeTitleDisplayMode);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>automatic：与上一个navigation item设置的largeTitleDisplayMode相同</p>
<p>always: 总是启用大标题。刚开始有个误解，always并不是说当scrollview滚动的时候，navigation bar一直是大标题模式，而是指，不管上一个viewcontroller设置的是什么，这个viewcontroller都是启用大标题</p>
<p>never：总是显示小标题模式，就是我们正常看到的导航栏标题样式</p>
<p>新增searchController属性</p>
<p>新增hidesSearchBarWhenScrolling：Bool属性, 配合searchController使用的，默认是true。<br>这个属性是控制searchController默认是否显示的。<br>通过上图也可以看到，searchBar默认是隐藏的，当下拉的时候才会显示出来，再上拉又会隐藏。<br>当设置为false时，searchBar会一直显示，当scrollview下拉时，searchBar会随着scrollview往下走，上拉时，则固定在顶部不动。</p>
</blockquote>
<h3 id="3-8-UITableView"><a href="#3-8-UITableView" class="headerlink" title="3.8 UITableView"></a>3.8 UITableView</h3><p>新增separatorInsetReference属性, 分割线相关的，有2个可选值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewSeparatorInsetReference</span>) &#123;</span><br><span class="line">    <span class="comment">// The value set to the separatorInset property is interpreted as an offset from the edges of the cell.</span></span><br><span class="line">    <span class="built_in">UITableViewSeparatorInsetFromCellEdges</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The value set to the separatorInset property is interpreted as an offset from the automatic separator insets.</span></span><br><span class="line">    <span class="built_in">UITableViewSeparatorInsetFromAutomaticInsets</span></span><br><span class="line">&#125; API_AVAILABLE(ios(<span class="number">11.0</span>), tvos(<span class="number">11.0</span>));</span><br></pre></td></tr></table></figure>
<p>TableView的separator默认左边会留15，如果要去掉这个空隙，顶头显示iOS 11之前的写法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_tableView.separatorInset = <span class="built_in">UIEdgeInsetsZero</span>;</span><br><span class="line">   _tableView.layoutMargins = <span class="built_in">UIEdgeInsetsZero</span>;</span><br></pre></td></tr></table></figure></p>
<p>iOS 11之后的写法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_tableView.separatorInsetReference = <span class="built_in">UITableViewSeparatorInsetFromCellEdges</span>;</span><br><span class="line">   _tableView.separatorInset = <span class="built_in">UIEdgeInsetsZero</span>;</span><br></pre></td></tr></table></figure>
<p>新增performBatchUpdates函数</p>
<p>TableViewCell的左划和右划手势功能<br>在UITableViewDelegate中，新增了两个delegate</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swipe actions</span></span><br><span class="line"><span class="comment">// These methods supersede -editActionsForRowAtIndexPath: if implemented</span></span><br><span class="line"><span class="comment">// return nil to get the default swipe actions</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UISwipeActionsConfiguration</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView leadingSwipeActionsConfigurationForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath API_AVAILABLE(ios(<span class="number">11.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UISwipeActionsConfiguration</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView trailingSwipeActionsConfigurationForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath API_AVAILABLE(ios(<span class="number">11.0</span>)) API_UNAVAILABLE(tvos);</span><br></pre></td></tr></table></figure>
<p>新增代理方法  Spring Loading</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring Loading</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows opting-out of spring loading for an particular row.</span></span><br><span class="line"><span class="comment">// If you want the interaction effect on a different subview of the spring loaded cell, modify the context.targetView property. The default is the cell.</span></span><br><span class="line"><span class="comment">// If this method is not implemented, the default is YES except when the row is part of a drag session.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)tableView:(<span class="built_in">UITableView</span> *)tableView shouldSpringLoadRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath withContext:(<span class="keyword">id</span>&lt;<span class="built_in">UISpringLoadedInteractionContext</span>&gt;)context API_AVAILABLE(ios(<span class="number">11.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br></pre></td></tr></table></figure>
<p>新增UITableViewDragDelegate 和 UITableViewDropDelegate代理</p>
<h3 id="3-9-推出了SafeArea-UI显示要在安全区域内"><a href="#3-9-推出了SafeArea-UI显示要在安全区域内" class="headerlink" title="3.9 推出了SafeArea(UI显示要在安全区域内)"></a>3.9 推出了SafeArea(UI显示要在安全区域内)</h3><p><strong>iPhone所有机型的尺寸表：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/8163699-bc15bd5b838be5ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1546239-994f620cfacb5e04.png"></p>
<p><strong>iPhone X基本属性</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/8163699-0b01578b72e7f0c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-10-21 下午3.14.57副本副本.png"></p>
<ul>
<li>启动图尺寸：1125px × 2436px(即 375pt × 812pt @3x))</li>
<li>iphoneX 屏幕高：812.0个点<ul>
<li>导航栏高度+状态栏高度：88.0个点(导航栏高度仍是44个点，状态栏高度增高为44个点，所以刘海的高度并不是状态栏的高度。状态栏和导航栏平分了头部总的高度）</li>
</ul>
</li>
<li>tabbar高度：83.0个点（原是固定49个点，增高了34个点).</li>
</ul>
<h3 id="顶部适配"><a href="#顶部适配" class="headerlink" title="顶部适配"></a>顶部适配</h3><hr>
<ul>
<li>iOS11automaticallyAdjustsScrollViewInsets属性废弃了 系统自己计算内边距 会出现ScorllView下沉20的现象</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/8163699-53e02b431aa04642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171021_8.png"></p>
<p>可以调用scrollview新的<code>apicontentInsetAdjustmentBehavior</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.automaticallyAdjustsScrollViewInsets = NO;</span><br><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">    self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这么写会导致在iPhoneX下出现，由于在X下安全区域的出现，顶部异形区域不建议覆盖，会造成视觉的差异</p>
<p><img src="http://upload-images.jianshu.io/upload_images/8163699-3c8df989c4fc363e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171021_10.png"></p>
<p>在代码中我们需要来根据设备高度来判断iPhoneX，从而来避免这种情况</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[tableview mas_makeConstraints:^(<span class="type">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">    make.edges.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">LL_iPhoneX</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">            make.top.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideTop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.view.mas_top).offset(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    make.<span class="keyword">left</span>.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">0</span>);</span><br><span class="line">    make.<span class="keyword">right</span>.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">0</span>);</span><br><span class="line">    make.bottom.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">0</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/8163699-857fb6b841632ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171021_11.png"></p>
<p>上面使用的Masonry,并且版本需要在V1.1.0版本</p>
<p><img src="http://upload-images.jianshu.io/upload_images/8163699-c270b1e0a8a52e4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171021_12.png"></p>
<p>苹果自己的约束代码如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *top = [contentView.topAnchor     constraintEqualToAnchor:<span class="keyword">self</span>.view.safeAreaLayoutGuide.top  <span class="type">Anchor</span>];</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *bottom = [contentView.bottomAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor];</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *<span class="keyword">left</span> = [contentView.leftAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.safeAreaLayoutGuide.leftAnchor];</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *<span class="keyword">right</span> = [contentView.rightAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.safeAreaLayoutGuide.rightAnchor];</span><br><span class="line">  [<span class="type">NSLayoutConstraint</span> activateConstraints:@[top, bottom, <span class="keyword">left</span>, <span class="keyword">right</span>]];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *top = [contentView.topAnchor constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor];</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *bottom = [contentView.bottomAnchor constraintEqualToAnchor:<span class="keyword">self</span>.bottomLayoutGuide.topAnchor];</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *<span class="keyword">left</span> = [contentView.leftAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.leftAnchor];</span><br><span class="line">  <span class="type">NSLayoutConstraint</span> *<span class="keyword">right</span> = [contentView.rightAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.rightAnchor];</span><br><span class="line">  [<span class="type">NSLayoutConstraint</span> activateConstraints:@[top, bottom, <span class="keyword">left</span>, <span class="keyword">right</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="适配宏"><a href="#适配宏" class="headerlink" title="适配宏"></a>适配宏</h3><hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIScreen width.</span></span><br><span class="line"><span class="meta">#define  kScreenWidth   [UIScreen mainScreen].bounds.size.width</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UIScreen height.</span></span><br><span class="line"><span class="meta">#define  kScreenHeight  [UIScreen mainScreen].bounds.size.height</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iPhone X</span></span><br><span class="line"><span class="meta">#define  Is_iPhoneX (kScreenWidth == 375.f &amp;&amp; kScreenHeight == 812.f ? YES : NO)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Status bar height.</span></span><br><span class="line"><span class="meta">#define  kStatusBarHeight      (Is_iPhoneX ? 44.f : 20.f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Navigation bar height.</span></span><br><span class="line"><span class="meta">#define  kNavigationBarHeight  44.f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tabbar height.</span></span><br><span class="line"><span class="meta">#define  kTabbarHeight         (Is_iPhoneX ? (49.f + 34.f) : 49.f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tabbar safe bottom margin.</span></span><br><span class="line"><span class="meta">#define  kTabbarSafeBottomMargin         (Is_iPhoneX ? 34.f : 0.f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Status bar &amp; navigation bar height.</span></span><br><span class="line"><span class="meta">#define  kStatusBarAndNavigationBarHeight  (Is_iPhoneX ? 88.f : 64.f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define kViewSafeAreInsets(view) (\</span></span><br><span class="line">  &#123;\</span><br><span class="line">    <span class="built_in">UIEdgeInsets</span> insets;\</span><br><span class="line">    <span class="keyword">if</span>(@available(iOS <span class="number">11.0</span>, *)) &#123;\</span><br><span class="line">      insets = view.safeAreaInsets; \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">      insets = <span class="built_in">UIEdgeInsetsZero</span>;\</span><br><span class="line">    &#125; \</span><br><span class="line">      insets;\</span><br><span class="line">  &#125;\</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/Linux/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/Linux/" itemprop="url">Linux学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux学习总结/" itemprop="url" rel="index">
                    <span itemprop="name">Linux学习总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Linux学习总结"><a href="#Linux学习总结" class="headerlink" title="Linux学习总结"></a>Linux学习总结</h1><h2 id="初识Linux"><a href="#初识Linux" class="headerlink" title="初识Linux"></a>初识Linux</h2><h3 id="为什么要学Linux"><a href="#为什么要学Linux" class="headerlink" title="为什么要学Linux"></a>为什么要学Linux</h3><p>如果你是一个前端的开发者，也许你和我有相似的经历：经常要和各种终端命令打交道，日常代码的版本管理，软件安装，或者搭建一个博客等等，它们的大多数的操作需要用命令行来完成。相比于各种操作的图形客户端，缺少了一种可视化的东西，但对于工作效率的提升绝有很大的帮助。就拿<strong>Git</strong>版本管理工具来说，你可以使用类似于<strong>Sourcetree</strong>或者<strong>tower</strong>等图形界面的管理工具，也可以使用看起来有些“原始”的命令行，但后者的多数指令是多平台通用的，省去了换一种图形工具就需要重新学习的麻烦，并且能完成较前者更复杂的操作。</p>
<p>如果你是一个后台开发。。。</p>
<p>所以，当回望大学期间的那段苦涩的Linux学习生涯，不得不感叹，自我驱动加上目的明确的学习方式，要比死记书本上茫茫的代码要有意义且效率的多。</p>
<p>既然目标明确了，这篇文章以下的部分就来从计算机基础部分开始，逐步展开Linux较为系统的学习，供以后查阅参考</p>
<hr>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统赋值调用计算机或者手机设备（硬件），提供其他软件可以运行的环境。</p>
<h3 id="操作系统的发展史"><a href="#操作系统的发展史" class="headerlink" title="操作系统的发展史"></a>操作系统的发展史</h3><ul>
<li><p><strong>Unix</strong></p>
<p>1965年之前的时候，电脑并不像现在一样普遍，<strong>它可不是一般人能碰的起的，除非是军事或者学院的研究机构</strong>，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑 </p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsbocawtmyj30bj08ngor.jpg" alt="image-20180615105311653"></p>
</li>
<li><p><strong>Minix</strong> </p>
<p>因为AT&amp;T的政策改变，在Version 7 Unix推出之后，<strong>发布新的使用条款</strong>，<strong>将**</strong>UNIX<strong>**源代码私有化</strong>，在大学中不再能使用UNIX源代码。Andrew S. Tanenbaum(<strong>塔能鲍姆</strong>，荷兰人美国国籍)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-UNIX）之意，将它称为MINIX。 </p>
</li>
<li><p><strong>Linux</strong> </p>
<p>1991年因为Minix只是教学使用，因此功能并不强，因此<strong>Torvalds</strong>（林纳斯·托瓦兹）<strong>利用GNU的bash（是许多Linux发行版的默认Shell）当做开发环境，gcc当做编译工具，编写了Linux内核-v0.02，</strong>但是一开始<strong>Linux</strong>并不能兼容<strong>Unix</strong>，即Unix上跑的应用程序不能在Linux上跑，即应用程序与内核之间的接口不一致，因为Unix是遵循POSIX规范的，因此Torvalds（托瓦尔兹）修改了Linux，并遵循POSIX（Portable Operating System Interface，他规范了应用程序与内核的接口规范）； 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件；</p>
<p>支持多任务</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fsbofmzrcfj308j06ujrx.jpg" alt="image-20180615105630625"></p>
</li>
</ul>
<blockquote>
<p>托瓦尔兹1969年12月28日出生于芬兰赫尔辛基市，父母都是记者。他从小就对计算机感兴趣。1988年他进入赫尔辛基大学学习，专业为计算机科学。1991年，他购买了一台属于自己的PC机。赫尔辛基大学当时采用Unix操作系统，托瓦尔兹觉得该产品性能不尽如人意，于是就尝试着自己编写一款操作系统内核，这就是Linux操作系统来源。1997年至2003年，托瓦尔兹在美国加州全美达(Transmeta)公司工作。2003年7月，他加盟“开放源代码开发实验室”(OSDL)，以全力开发Linux内核。后来OSDL与“免费标准集团”(FSG)合并成立了Linux基金会。托瓦尔兹如今仍在Linux基金会工作</p>
</blockquote>
<h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsbon69xpcj30bj08amzl.jpg" alt="image-20180615110344283"></p>
<p><strong>Ubuntu</strong>（友帮拓、优般图、乌班图）是一个以<a href="http://baike.baidu.com/item/%25E6%25A1%258C%25E9%259D%25A2" target="_blank" rel="noopener">桌面</a>应用为主的开源GNU/Linux操作系统，Ubuntu 是基于<a href="http://baike.baidu.com/item/Debian" target="_blank" rel="noopener">Debian</a> GNU/<a href="http://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>，支持x86、amd64（即x64）和<a href="http://baike.baidu.com/item/ppc/150" target="_blank" rel="noopener">ppc</a>架构，由全球化的专业开发团队（Canonical Ltd）打造的。</p>
<p><strong>Red Hat</strong>公司发布的面向企业用户的Linux操作系统。</p>
<p><strong>SUSE</strong>(发音 /ˈsuːsə/)是指SUSE Linux ，是德国 SuSE Linux AG公司发行维护的Linux发行版，是属于此公司的注册商标。第一个版本出现在1994年年初。2004年这家公司被Novell公司收购。</p>
<p><strong>Fedora</strong> 是一个 <a href="http://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a> 发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发，这个社群的成员以自己的不懈努力，提供并维护自由、<a href="http://baike.baidu.com/item/%25E5%25BC%2580%25E6%2594%25BE%25E6%25BA%2590%25E7%25A0%2581" target="_blank" rel="noopener">开放源码</a>的软件和开放的标准。Fedora 项目由 Fedora 基金会管理和控制，得到了 Red Hat 的支持。</p>
<h3 id="Linux不同版本及应用领域"><a href="#Linux不同版本及应用领域" class="headerlink" title="Linux不同版本及应用领域"></a>Linux不同版本及应用领域</h3><h4 id="Linux内核及发行版本介绍"><a href="#Linux内核及发行版本介绍" class="headerlink" title="Linux内核及发行版本介绍"></a>Linux内核及发行版本介绍</h4><ul>
<li><p><strong>Linux内核版本</strong></p>
<p><strong>内核</strong>(kernel)是系统的心脏<strong>，</strong>是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。</p>
<p>Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环：</p>
<p>   稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。</p>
<p>   开发版：由于要试验各种解决方案，所以变化很快。</p>
<p>内核源码网址：<a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a> 所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus（林纳斯·托瓦兹）领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中。</p>
</li>
<li><p><strong>Linux发行版本</strong></p>
<p>Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。 </p>
<p><strong>GNU</strong>计划：又称革奴计划，是由<a href="http://baike.baidu.com/item/Richard%2520Stallman" target="_blank" rel="noopener">Richard Stallman</a>在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。Richard Stallman最早是在net.unix-wizards新闻组上公布该消息，并附带《GNU宣言》等解释为何发起该计划的文章，其中一个理由就是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU通用公共许可证（GNU General Public License，GPL）。即“反版权”（或称Copyleft）概念。 </p>
</li>
</ul>
<h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a><strong>应用领域</strong></h4><ul>
<li><p><strong>个人桌面领域的应用</strong> </p>
<p>此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺点，一直被windows所压制，但近些年来随着ubuntu、fedora [fɪˈdɔ:rə] 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高</p>
<p>典型代表：ubuntu、fedora [fɪ’dɔːrə]、suse linux</p>
<p>在Ubuntu中玩QQ</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsbpoefy2uj30bj073tci.jpg" alt="image-20180615113931426"></p>
</li>
</ul>
<p>  <img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsbpor0im3j30bj06htcf.jpg" alt="image-20180615113949770"></p>
<ul>
<li><p><strong>服务器领域</strong> </p>
<p>linux在服务器领域的应用是其重要分支</p>
<p>linux免费、稳定、高效等特点在这里得到了很好的体现，但早期因为维护、运行等原因同样受到了很大的限制，但近些年来linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛</p>
<p>典型代表：</p>
<p>​    Red Hat公司的AS系列</p>
<p>​    完全开源的debian系列</p>
<p>​    suse EnterPrise 11系列等</p>
</li>
<li><p><strong>嵌入式领域</strong> </p>
<p>智能硬件</p>
<p>近些年来linux在嵌入式领域的应用得到了飞速的提高</p>
<p>l<strong>inux</strong>运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高</p>
<p>主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域，得到了摩托罗拉、三星、NEC、Google等公司的大力推广</p>
</li>
</ul>
<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>在常用的Windows平台下，打开计算机，我们可以看到多个树并列的目录结构</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsbsj2lsi4j307702djra.jpg" alt="image-20180615131811721"></p>
<p>在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fsbsjtdrnrj30bj048aan.jpg" alt="image-20180615131855388"></p>
<ul>
<li><p><strong>类Unix系统目录结构</strong></p>
<p>linux没有盘符这个概念，只有一个根目录/，所有文件都在它下面 </p>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fsbslhc1euj30bj079t8x.jpg" alt="image-20180615132031382"></p>
<ul>
<li><p><strong>打开控制台快捷键：Ctrl+Alt+T</strong> </p>
<p>控制台文字调大：Ctrl+Shift++（Ctrl键加上Shift加载+号）</p>
<p>控制台文字调小：Ctrl+-（（Ctrl键加上减号）</p>
</li>
<li><p><strong>在一个控制层打开另外一个窗口：Ctrl+Shift+T</strong> </p>
<p>打开多个窗口命令：Ctrl+Shift+T</p>
<p>切换到第一个窗口：Alt+1</p>
<p>切换到第二个窗口：Alt+2</p>
<p>切换到第三个窗口：Alt+3</p>
<p>退出窗口命令：exit</p>
</li>
</ul>
<h4 id="Linux目录简介"><a href="#Linux目录简介" class="headerlink" title="Linux目录简介"></a>Linux目录简介</h4><ul>
<li><strong>/</strong>：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。 </li>
<li><strong>/bin</strong>：/usr/bin: 可执行二进制文件的目录，程序就安装在这个目录，如常用的命令ls、tar、mv、cat等。 </li>
<li><strong>/boot</strong>：（引导的意思）放置linux系统启动时用到的一些文件，如果删除了，电脑有又可能启动不了，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。 </li>
<li>/<strong>dev</strong>：存放<strong>linux</strong>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。 </li>
<li><strong>/etc</strong>：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。 </li>
<li><strong>/home</strong>：系统默认的用户<strong>家目录</strong>，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。<strong>注意，以后你要做任何事情建议都在这里做，其他目录不要随便删除。</strong> </li>
<li><strong>/lib、/usr/lib、/usr/local/lib</strong>：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。 </li>
<li><strong>/root</strong>：系统管理员root的家目录。 </li>
<li><strong>/lost+fount</strong>：系统异常产生错误时，会将一些遗失的片段放置于此目录下。 </li>
<li><strong>/mnt: /media</strong>：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。 </li>
<li><strong>/opt</strong>：给主机额外安装软件所摆放的目录。 </li>
<li><strong>/proc</strong>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/ 等。 </li>
<li><strong>/sbin、/usr/sbin、/usr/local/sbin</strong>：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。 </li>
<li><strong>/tmp</strong>：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。 </li>
<li><strong>/srv</strong>：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。 </li>
<li><strong>/usr</strong>：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。 </li>
<li><strong>/var</strong>：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。 </li>
</ul>
<h4 id="用户目录"><a href="#用户目录" class="headerlink" title="用户目录"></a><strong>用户目录</strong></h4><p><strong>cd命令</strong></p>
<p>cd是change dir 简称，用于切换目录 </p>
<p><strong>家目录</strong> </p>
<p>位于/home/user，称之为用户工作目录或<strong>家目录</strong>,表示方式： </p>
<p><strong>查看当前在个目录，pwd</strong> </p>
<p><strong>跳转到当前用户的家目录</strong>，cd ~</p>
<h4 id="文件权限理解"><a href="#文件权限理解" class="headerlink" title="文件权限理解"></a><strong>文件权限理解</strong></h4><ul>
<li><p><strong>文件权限</strong> </p>
<p>文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。</p>
<p>Unix/Linux<strong>系统是一个典型的多用户系统</strong>，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</p>
<p>在 Unix/Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。</p>
</li>
<li><p><strong>访问用户</strong> </p>
<p>通过设定权限可以从以下三种访问方式限制访问权限： </p>
<ol>
<li>只允许用户自己访问（<strong>所有者</strong>） 所有者就是创建文件的用户，用户是所有用户所创建文件的所有者，用户可以允许所在的用户组能访问用户的文件。</li>
<li>允许一个预先指定的用户组中的用户访问（<strong>用户组</strong>） 用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。</li>
<li>允许系统中的任何用户访问（<strong>其他用户</strong>） 用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是 other 用户类 </li>
</ol>
</li>
<li><p><strong>访问权限</strong> </p>
<p>用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限：</p>
<p>读权限（r） 对文件而言，具有<strong>读取文件内容的</strong>权限；对目录来说，<strong>具有浏览目录的权限。</strong></p>
<p>写权限（w） 对文件而言，具有<strong>新增、修改文件内容的权限</strong>；对目录来说，具有<strong>删除、移动目录内文件的权限</strong>。</p>
<p>可执行权限（x） 对文件而言，具有<strong>执行文件的权限</strong>；对目录来说该用户具有<strong>进入目录的权限。</strong></p>
<p>注意：通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。</p>
</li>
<li><p><strong>示例说明</strong> </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsbty1cp2ej30bj06vtbt.jpg" alt="image-20180615140711619">、</p>
<p>第1个字母代表文件的类型：<strong>“d”</strong> <strong>代表文件夹、</strong>“-” <strong>代表普通文件</strong>、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件(l是L的小写)。 后 9 个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。 </p>
<p>每一个用户都有它自身的读、写和执行权限。 </p>
<p>第一组权限控制访问自己的文件权限，即所有者权限。</p>
<p>第二组权限控制用户组访问其中一个用户的文件的权限。</p>
<p>第三组权限控制其他所有用户访问一个用户的文件的权限。</p>
<p>这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。 </p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://simplecoder.cn/2018/06/21/关联对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/关联对象/" itemprop="url">关联对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T10:14:33+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/OC/" itemprop="url" rel="index">
                    <span itemprop="name">OC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h1><p>先来思考一个问题：如何实现给分类“添加成员变量”？</p>
<p>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">// 对象方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span> <span class="comment">// 类方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span> <span class="comment">// 协议</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分类的结构体内部有一个<code>struct property_list_t *instanceProperties</code>结构体成员，所以我们可以向分类里面添加属性。但此时系统并不会为我们生成对应的成员变量以及set、get方法。</p>
<h2 id="你可能想到的方案"><a href="#你可能想到的方案" class="headerlink" title="你可能想到的方案"></a>你可能想到的方案</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>既然系统不会帮我们生成对应的set、get方法，我们不妨自己来实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *_name;</span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，我们使用一个静态的全局变量<code>static NSString *_name</code>来保存分类的“成员变量”，当调用类的set或者get方法时，我们内部把值赋给自己创建的全局变量，这样就能实现外观上看起来和成员变量没什么差异。</p>
<p>但存在的问题也显而易见。</p>
<p>首先这个全局变量我们不好管理它的内存，其次是多个对象共用一个全局变量，会导致前面设置的值被后面的覆盖。</p>
<h3 id="全局字典"><a href="#全局字典" class="headerlink" title="全局字典"></a>全局字典</h3><p>或许你还会想到用全局字典来解决。</p>
<p>比如，分类里有两个属性<code>name,weight</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define SPKey [NSString stringWithFormat:@<span class="meta-string">"%p"</span>, self]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *names_;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *weights_;</span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    weights_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    names_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    names_[SPKey] = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> names_[SPKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight</span><br><span class="line">&#123;</span><br><span class="line">    weights_[SPKey] = @(weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)weight</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [weights_[SPKey] intValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式能够解决上个方法内存共用的问题，但无法解决内存管理的问题。当然还有其他风险：比如线程安全问题。</p>
<h2 id="使用RunTime动态添加属性"><a href="#使用RunTime动态添加属性" class="headerlink" title="使用RunTime动态添加属性"></a>使用RunTime动态添加属性</h2><p>RunTime提供了动态添加属性和获得属性的API。</p>
<ul>
<li><p>添加关联对象</p>
<p>void objc_setAssociatedObject(id object, const void * key,  id value, objc_AssociationPolicy policy)</p>
<p>第一个参数<code>object</code>：给哪个对象添加属性</p>
<p>第二个参数<code>const void * key</code>:属性名，根据key获取关联对象的属性的值，在<code>objc_getAssociatedObject</code>中通过次key获得属性的值并返回。</p>
<p>第三个参数<code>id value</code>: 关联的值，也就是set方法传入的值给属性去保存。</p>
<p>第四个参数<code>objc_AssociationPolicy policy</code>:策略，属性以什么形式保存。</p>
</li>
<li><p>获得关联对象</p>
<p> id objc_getAssociatedObject(id object, const void * key)</p>
<p>第一个参数<code>id object</code>:获取哪个对象里面的关联的属性.。</p>
<p>第二个参数<code>const void * key</code>:什么属性，与<code>objc_setAssociatedObject</code>中的key相对应，即通过key值取出value。</p>
</li>
<li><p>移除所有的关联对象</p>
<p>void objc_removeAssociatedObjects( id object)</p>
</li>
</ul>
<p>关于<code>objc_AssociationPolicy</code>,和我们之前学习的属性存储策略类似，有以下几个部分：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw6rpiw4fmj30y108g3zy.jpg" alt="objc_AssociationPolicy"></p>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person+Test.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 隐式参数</span></span><br><span class="line">    <span class="comment">// _cmd == @selector(name)</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)weight</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _cmd == @selector(weight)</span></span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) intValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这样我们就能成功的将name、weight关联到Person类所创建的对象中。</p>
<p>以上就是关联对象的使用方式，过程并不复杂。但是我们也许不甘止步于此，你可能还会想，<code>Runtime</code>底层到底做了些什么？其本质是不是和分类其他元素一样，被添加到了类属性列表里面？</p>
<h2 id="关联对象的内部实现"><a href="#关联对象的内部实现" class="headerlink" title="关联对象的内部实现"></a>关联对象的内部实现</h2><p>我们来到<code>runtime</code>源码实现部分。首先找到<code>objc_setAssociatedObject</code>函数，其内部调用的是<code>_object_set_associative_reference</code>函数。我们点击查看<code>_object_set_associative_reference</code>实现的详情部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(id object, <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h3><p>这是一个全局的管理者对象，其内部管理着一组<code>AssociationsHashMap</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span></span><br><span class="line">    <span class="comment">// associative references: object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="AssociationsHashMap"><a href="#AssociationsHashMap" class="headerlink" title="AssociationsHashMap"></a>AssociationsHashMap</h3><p>我们来看一下AssociationsHashMap内部的源码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsHashMap</span> :</span> <span class="keyword">public</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">disguised_ptr_t</span>, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> ::<span class="built_in">malloc</span>(n); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123; ::<span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其内部维护着一组<code>ObjectAssociationMap</code></p>
<h3 id="ObjectAssociationMap"><a href="#ObjectAssociationMap" class="headerlink" title="ObjectAssociationMap"></a>ObjectAssociationMap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAssociationMap</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> ::<span class="built_in">malloc</span>(n); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123; ::<span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出ObjectAssociationMap中维护了一组<code>ObjcAssociation</code>,继续深入源码。</p>
<h3 id="ObjcAssociation"><a href="#ObjcAssociation" class="headerlink" title="ObjcAssociation"></a>ObjcAssociation</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">    id _value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ObjcAssociation(<span class="keyword">uintptr_t</span> policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(<span class="number">0</span>), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> policy() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _policy; &#125;</span><br><span class="line">    <span class="function">id <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _value != nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们发现ObjcAssociation存储着<code>_policy、value</code>，而这两个值我们可以发现正是我们调用<code>objc_setAssociatedObject</code>函数传入的值，也就是说我们在调用<code>objc_setAssociatedObject</code>函数中传入的value和policy这两个值最终是存储在<code>ObjcAssociation</code>中的。</p>
<p>以上四者的关系可以用以下这幅图来概括：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw6vlg0evzj31hz0p279z.jpg" alt="关联对象底层对象关系"></p>
<p>所以，关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中，如果设置关联对象为nil，就相当于是移除关联对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
